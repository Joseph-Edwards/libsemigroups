<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsemigroups: libsemigroups::FroidurePin&lt; TElementType, TElementHash, TElementEqual, TTraits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classlibsemigroups_1_1_froidure_pin-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libsemigroups::FroidurePin&lt; TElementType, TElementHash, TElementEqual, TTraits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for semigroups generated by instances of <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>.  
 <a href="classlibsemigroups_1_1_froidure_pin.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="froidure-pin_8hpp_source.html">froidure-pin.hpp</a>&gt;</code></p>

<p>Inherits TTraits, and libsemigroups::FroidurePinBase.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7f361c72a836a7c965453ce8ec7edda"><td class="memItemLeft" align="right" valign="top"><a id="ac7f361c72a836a7c965453ce8ec7edda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cayley_graph_type</b> = internal::RecVec&lt; element_index_type &gt;</td></tr>
<tr class="separator:ac7f361c72a836a7c965453ce8ec7edda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea56a0c341558491b5f60c71e4a098"><td class="memItemLeft" align="right" valign="top"><a id="a94ea56a0c341558491b5f60c71e4a098"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_element_type</b> = typename TTraits::const_element_type</td></tr>
<tr class="separator:a94ea56a0c341558491b5f60c71e4a098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95514b17592385e49be35b4a08a5c7b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> = internal::iterator_base&lt; internal_element_type, const_pointer, const_reference, element_type, iterator_methods &gt;</td></tr>
<tr class="memdesc:a95514b17592385e49be35b4a08a5c7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for const iterators through the elements of <code>this</code>, in the order they were enumerated (i.e. in short-lex order of the minimum word in the generators of <code>this</code> equal to any given element).  <a href="#a95514b17592385e49be35b4a08a5c7b4">More...</a><br /></td></tr>
<tr class="separator:a95514b17592385e49be35b4a08a5c7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b4bc2ed33c1888222bbb7012850593"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593">const_iterator_idempotents</a> = const_iterator_pair_first</td></tr>
<tr class="memdesc:ad7b4bc2ed33c1888222bbb7012850593"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for const iterators through the idempotents of <code>this</code>, in short-lex order.  <a href="#ad7b4bc2ed33c1888222bbb7012850593">More...</a><br /></td></tr>
<tr class="separator:ad7b4bc2ed33c1888222bbb7012850593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b25fb1414699d00d393cf1b263e4c5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d">const_iterator_sorted</a> = const_iterator_pair_first</td></tr>
<tr class="memdesc:a1b25fb1414699d00d393cf1b263e4c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for const iterators through the elements of <code>this</code>, sorted according to TTraits::less.  <a href="#a1b25fb1414699d00d393cf1b263e4c5d">More...</a><br /></td></tr>
<tr class="separator:a1b25fb1414699d00d393cf1b263e4c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded72de60da916588deb9e53a702243f"><td class="memItemLeft" align="right" valign="top"><a id="aded72de60da916588deb9e53a702243f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename TTraits::const_pointer</td></tr>
<tr class="separator:aded72de60da916588deb9e53a702243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafe303578131f4bc43e763112f46c87"><td class="memItemLeft" align="right" valign="top"><a id="abafe303578131f4bc43e763112f46c87"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = typename TTraits::const_reference</td></tr>
<tr class="separator:abafe303578131f4bc43e763112f46c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbeec3bafafb5f03e6c3e367fa46fd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a8bbeec3bafafb5f03e6c3e367fa46fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for const reverse iterators through the elements of <code>this</code>, in the reverse order of enumeration.  <a href="#a8bbeec3bafafb5f03e6c3e367fa46fd1">More...</a><br /></td></tr>
<tr class="separator:a8bbeec3bafafb5f03e6c3e367fa46fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3e00b4dad5fbf1d3c151ef3ffaae8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae7a3e00b4dad5fbf1d3c151ef3ffaae8">const_reverse_iterator_idempotents</a> = const_reverse_iterator_pair_first</td></tr>
<tr class="memdesc:ae7a3e00b4dad5fbf1d3c151ef3ffaae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for reverse const iterators through the idempotents of <code>this</code>, in short-lex order.  <a href="#ae7a3e00b4dad5fbf1d3c151ef3ffaae8">More...</a><br /></td></tr>
<tr class="separator:ae7a3e00b4dad5fbf1d3c151ef3ffaae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece8d9dcc0c9eadd25e6e3d8eef032e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3">const_reverse_iterator_sorted</a> = const_reverse_iterator_pair_first</td></tr>
<tr class="memdesc:aece8d9dcc0c9eadd25e6e3d8eef032e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for const reverse iterators through the elements of <code>this</code>, sorted according to TTraits::less.  <a href="#aece8d9dcc0c9eadd25e6e3d8eef032e3">More...</a><br /></td></tr>
<tr class="separator:aece8d9dcc0c9eadd25e6e3d8eef032e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c7534ce8fe2bf635aa271d755fbaa6"><td class="memItemLeft" align="right" valign="top"><a id="a22c7534ce8fe2bf635aa271d755fbaa6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_index_type</b> = FroidurePinBase::element_index_type</td></tr>
<tr class="separator:a22c7534ce8fe2bf635aa271d755fbaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ed443a02db20d672515485b0004549"><td class="memItemLeft" align="right" valign="top"><a id="a04ed443a02db20d672515485b0004549"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_type</b> = typename TTraits::element_type</td></tr>
<tr class="separator:a04ed443a02db20d672515485b0004549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a065ff79b4db6cc69d70ac861d8be6"><td class="memItemLeft" align="right" valign="top"><a id="a83a065ff79b4db6cc69d70ac861d8be6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = FroidurePinBase::size_type</td></tr>
<tr class="separator:a83a065ff79b4db6cc69d70ac861d8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f429294dce44f883223135c7ff41d33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a2f429294dce44f883223135c7ff41d33">FroidurePin</a> (std::vector&lt; element_type &gt; const *)</td></tr>
<tr class="memdesc:a2f429294dce44f883223135c7ff41d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from generators.  <a href="#a2f429294dce44f883223135c7ff41d33">More...</a><br /></td></tr>
<tr class="separator:a2f429294dce44f883223135c7ff41d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7bb7a6bdfa1a4e2d3848e6d7a1e768"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1d7bb7a6bdfa1a4e2d3848e6d7a1e768">FroidurePin</a> (std::vector&lt; element_type &gt; const &amp;)</td></tr>
<tr class="memdesc:a1d7bb7a6bdfa1a4e2d3848e6d7a1e768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from generators.  <a href="#a1d7bb7a6bdfa1a4e2d3848e6d7a1e768">More...</a><br /></td></tr>
<tr class="separator:a1d7bb7a6bdfa1a4e2d3848e6d7a1e768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240cb7c614710898be33b7143133842"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a3240cb7c614710898be33b7143133842">FroidurePin</a> (std::initializer_list&lt; element_type &gt;)</td></tr>
<tr class="memdesc:a3240cb7c614710898be33b7143133842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from generators.  <a href="#a3240cb7c614710898be33b7143133842">More...</a><br /></td></tr>
<tr class="separator:a3240cb7c614710898be33b7143133842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65786861e9c2b49618980887ad312ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae65786861e9c2b49618980887ad312ab">FroidurePin</a> (<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> const &amp;)</td></tr>
<tr class="memdesc:ae65786861e9c2b49618980887ad312ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ae65786861e9c2b49618980887ad312ab">More...</a><br /></td></tr>
<tr class="separator:ae65786861e9c2b49618980887ad312ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41031b82ab19bc8ae5be89e71e7e113c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a41031b82ab19bc8ae5be89e71e7e113c">~FroidurePin</a> ()</td></tr>
<tr class="memdesc:a41031b82ab19bc8ae5be89e71e7e113c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default destructor.  <a href="#a41031b82ab19bc8ae5be89e71e7e113c">More...</a><br /></td></tr>
<tr class="separator:a41031b82ab19bc8ae5be89e71e7e113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beea877d9d37caaf2f6406456c9231a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a5beea877d9d37caaf2f6406456c9231a">add_generator</a> (element_type const &amp;)</td></tr>
<tr class="memdesc:a5beea877d9d37caaf2f6406456c9231a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the generators <code>coll</code> to the generators of <code>this</code>.  <a href="#a5beea877d9d37caaf2f6406456c9231a">More...</a><br /></td></tr>
<tr class="separator:a5beea877d9d37caaf2f6406456c9231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176683743fa2b3dbca5ad0f5ee87f4fa"><td class="memTemplParams" colspan="2"><a id="a176683743fa2b3dbca5ad0f5ee87f4fa"></a>
template&lt;class TCollection &gt; </td></tr>
<tr class="memitem:a176683743fa2b3dbca5ad0f5ee87f4fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_generators</b> (TCollection const &amp;)</td></tr>
<tr class="separator:a176683743fa2b3dbca5ad0f5ee87f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f322722ac56a1ae74b236f25dd5c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af6f322722ac56a1ae74b236f25dd5c3b">add_generators</a> (std::initializer_list&lt; const_element_type &gt;)</td></tr>
<tr class="memdesc:af6f322722ac56a1ae74b236f25dd5c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the generators <code>coll</code> to the generators of <code>this</code>.  <a href="#af6f322722ac56a1ae74b236f25dd5c3b">More...</a><br /></td></tr>
<tr class="separator:af6f322722ac56a1ae74b236f25dd5c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7272ba920f61eb20fdaad08e25e0ca8a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7272ba920f61eb20fdaad08e25e0ca8a">at</a> (element_index_type)</td></tr>
<tr class="memdesc:a7272ba920f61eb20fdaad08e25e0ca8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element of the semigroup in position <code>pos</code>, or a <code>nullptr</code> if there is no such element.  <a href="#a7272ba920f61eb20fdaad08e25e0ca8a">More...</a><br /></td></tr>
<tr class="separator:a7272ba920f61eb20fdaad08e25e0ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea8a2639f0ef0f27f1a56a1b1dc31b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#afdea8a2639f0ef0f27f1a56a1b1dc31b">batch_size</a> () const noexcept override</td></tr>
<tr class="memdesc:afdea8a2639f0ef0f27f1a56a1b1dc31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the batch size. This is the minimum number of elements enumerated in any call to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5e3d6358f5011c8fcefd59c42fca2f" title="Enumerate the semigroup until limit elements are found or killed is true. ">FroidurePin::enumerate</a>.  <a href="#afdea8a2639f0ef0f27f1a56a1b1dc31b">More...</a><br /></td></tr>
<tr class="separator:afdea8a2639f0ef0f27f1a56a1b1dc31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4729e02da96b8d94b94305eda21e01c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a4729e02da96b8d94b94305eda21e01c1">begin</a> () const</td></tr>
<tr class="memdesc:a4729e02da96b8d94b94305eda21e01c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to the first element of the semigroup.  <a href="#a4729e02da96b8d94b94305eda21e01c1">More...</a><br /></td></tr>
<tr class="separator:a4729e02da96b8d94b94305eda21e01c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150d15a31a7d49864cf33a68a612ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a6150d15a31a7d49864cf33a68a612ead">cbegin</a> () const</td></tr>
<tr class="memdesc:a6150d15a31a7d49864cf33a68a612ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to the first element of the semigroup.  <a href="#a6150d15a31a7d49864cf33a68a612ead">More...</a><br /></td></tr>
<tr class="separator:a6150d15a31a7d49864cf33a68a612ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed153f10e29c866569a0e4bbf57ec5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593">const_iterator_idempotents</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1ed153f10e29c866569a0e4bbf57ec5b">cbegin_idempotents</a> ()</td></tr>
<tr class="memdesc:a1ed153f10e29c866569a0e4bbf57ec5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing at the first idempotent in the semigroup.  <a href="#a1ed153f10e29c866569a0e4bbf57ec5b">More...</a><br /></td></tr>
<tr class="separator:a1ed153f10e29c866569a0e4bbf57ec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df3a8c3a80702bede19a3813897880a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d">const_iterator_sorted</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a2df3a8c3a80702bede19a3813897880a">cbegin_sorted</a> ()</td></tr>
<tr class="memdesc:a2df3a8c3a80702bede19a3813897880a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to the first element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>.  <a href="#a2df3a8c3a80702bede19a3813897880a">More...</a><br /></td></tr>
<tr class="separator:a2df3a8c3a80702bede19a3813897880a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554cea35b83f0f43e9afa40fcab564ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a554cea35b83f0f43e9afa40fcab564ba">cend</a> () const</td></tr>
<tr class="memdesc:a554cea35b83f0f43e9afa40fcab564ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to one past the last currently known element of the semigroup.  <a href="#a554cea35b83f0f43e9afa40fcab564ba">More...</a><br /></td></tr>
<tr class="separator:a554cea35b83f0f43e9afa40fcab564ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a567f5dfd52d56da97368478a10dbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593">const_iterator_idempotents</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af3a567f5dfd52d56da97368478a10dbc">cend_idempotents</a> ()</td></tr>
<tr class="memdesc:af3a567f5dfd52d56da97368478a10dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator referring to past the end of the last idempotent in the semigroup.  <a href="#af3a567f5dfd52d56da97368478a10dbc">More...</a><br /></td></tr>
<tr class="separator:af3a567f5dfd52d56da97368478a10dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4602d52957b4b6720e84db2ff8ee64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d">const_iterator_sorted</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a6c4602d52957b4b6720e84db2ff8ee64">cend_sorted</a> ()</td></tr>
<tr class="memdesc:a6c4602d52957b4b6720e84db2ff8ee64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to one past the last element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>.  <a href="#a6c4602d52957b4b6720e84db2ff8ee64">More...</a><br /></td></tr>
<tr class="separator:a6c4602d52957b4b6720e84db2ff8ee64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d183298c1674e99f4af25f507b9d88b"><td class="memTemplParams" colspan="2">template&lt;class TCollection &gt; </td></tr>
<tr class="memitem:a5d183298c1674e99f4af25f507b9d88b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a5d183298c1674e99f4af25f507b9d88b">closure</a> (TCollection const &amp;coll)</td></tr>
<tr class="memdesc:a5d183298c1674e99f4af25f507b9d88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>.  <a href="#a5d183298c1674e99f4af25f507b9d88b">More...</a><br /></td></tr>
<tr class="separator:a5d183298c1674e99f4af25f507b9d88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ca700bd25d6c246c3beb119608e931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae6ca700bd25d6c246c3beb119608e931">closure</a> (std::initializer_list&lt; const_element_type &gt;)</td></tr>
<tr class="memdesc:ae6ca700bd25d6c246c3beb119608e931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>.  <a href="#ae6ca700bd25d6c246c3beb119608e931">More...</a><br /></td></tr>
<tr class="separator:ae6ca700bd25d6c246c3beb119608e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb734853b124748c84f2c1b34b3f729f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#afb734853b124748c84f2c1b34b3f729f">concurrency_threshold</a> () const noexcept override</td></tr>
<tr class="memdesc:afb734853b124748c84f2c1b34b3f729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of.  <a href="#afb734853b124748c84f2c1b34b3f729f">More...</a><br /></td></tr>
<tr class="separator:afb734853b124748c84f2c1b34b3f729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca6d89e44d8a97d7ed813ed3d12534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a9aca6d89e44d8a97d7ed813ed3d12534">contains</a> (const_reference)</td></tr>
<tr class="memdesc:a9aca6d89e44d8a97d7ed813ed3d12534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>x</code> is an element of <code>this</code> and <code>false</code> if it is not.  <a href="#a9aca6d89e44d8a97d7ed813ed3d12534">More...</a><br /></td></tr>
<tr class="separator:a9aca6d89e44d8a97d7ed813ed3d12534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b269953ddf51f27bc21d9e4c1872b3b"><td class="memTemplParams" colspan="2">template&lt;class TCollection &gt; </td></tr>
<tr class="memitem:a7b269953ddf51f27bc21d9e4c1872b3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7b269953ddf51f27bc21d9e4c1872b3b">copy_add_generators</a> (TCollection const &amp;) const</td></tr>
<tr class="memdesc:a7b269953ddf51f27bc21d9e4c1872b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new semigroup generated by <code>this</code> and <code>coll</code>.  <a href="#a7b269953ddf51f27bc21d9e4c1872b3b">More...</a><br /></td></tr>
<tr class="separator:a7b269953ddf51f27bc21d9e4c1872b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5545a82f9f79139ad74dc1049bbedc8"><td class="memTemplParams" colspan="2">template&lt;class TCollection &gt; </td></tr>
<tr class="memitem:ac5545a82f9f79139ad74dc1049bbedc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac5545a82f9f79139ad74dc1049bbedc8">copy_closure</a> (TCollection const &amp;)</td></tr>
<tr class="memdesc:ac5545a82f9f79139ad74dc1049bbedc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new semigroup generated by <code>this</code> and copies of the non-redundant elements of <code>coll</code>.  <a href="#ac5545a82f9f79139ad74dc1049bbedc8">More...</a><br /></td></tr>
<tr class="separator:ac5545a82f9f79139ad74dc1049bbedc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0278707854105f166a5a3a1e075a214e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a0278707854105f166a5a3a1e075a214e">crbegin</a> () const</td></tr>
<tr class="memdesc:a0278707854105f166a5a3a1e075a214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator pointing to the last currently known element of the semigroup.  <a href="#a0278707854105f166a5a3a1e075a214e">More...</a><br /></td></tr>
<tr class="separator:a0278707854105f166a5a3a1e075a214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425e6689e5a51934de6e91ec0d4ea852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3">const_reverse_iterator_sorted</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a425e6689e5a51934de6e91ec0d4ea852">crbegin_sorted</a> ()</td></tr>
<tr class="memdesc:a425e6689e5a51934de6e91ec0d4ea852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to the last element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>.  <a href="#a425e6689e5a51934de6e91ec0d4ea852">More...</a><br /></td></tr>
<tr class="separator:a425e6689e5a51934de6e91ec0d4ea852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf4000e834607b00043249be0c6d882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a2cf4000e834607b00043249be0c6d882">crend</a> () const</td></tr>
<tr class="memdesc:a2cf4000e834607b00043249be0c6d882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator pointing to one before the first element of the semigroup.  <a href="#a2cf4000e834607b00043249be0c6d882">More...</a><br /></td></tr>
<tr class="separator:a2cf4000e834607b00043249be0c6d882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa198d7fda4568d5bf1187401357de4dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3">const_reverse_iterator_sorted</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aa198d7fda4568d5bf1187401357de4dc">crend_sorted</a> ()</td></tr>
<tr class="memdesc:aa198d7fda4568d5bf1187401357de4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to one before the first element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>.  <a href="#aa198d7fda4568d5bf1187401357de4dc">More...</a><br /></td></tr>
<tr class="separator:aa198d7fda4568d5bf1187401357de4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2044c9081774ce69b1ba9275d44119"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a6f2044c9081774ce69b1ba9275d44119">current_max_word_length</a> () const noexcept override</td></tr>
<tr class="memdesc:a6f2044c9081774ce69b1ba9275d44119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum length of a word in the generators so far computed.  <a href="#a6f2044c9081774ce69b1ba9275d44119">More...</a><br /></td></tr>
<tr class="separator:a6f2044c9081774ce69b1ba9275d44119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543b9ffde8dbaf11c8562de69a02dd13"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a543b9ffde8dbaf11c8562de69a02dd13">current_nr_rules</a> () const noexcept override</td></tr>
<tr class="memdesc:a543b9ffde8dbaf11c8562de69a02dd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of relations in the presentation for the semigroup that have been found so far.  <a href="#a543b9ffde8dbaf11c8562de69a02dd13">More...</a><br /></td></tr>
<tr class="separator:a543b9ffde8dbaf11c8562de69a02dd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51625044ad0c6ea774375037f662a9"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7d51625044ad0c6ea774375037f662a9">current_position</a> (const_reference x) const</td></tr>
<tr class="memdesc:a7d51625044ad0c6ea774375037f662a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the element <code>x</code> in the semigroup if it is already known to belong to the semigroup.  <a href="#a7d51625044ad0c6ea774375037f662a9">More...</a><br /></td></tr>
<tr class="separator:a7d51625044ad0c6ea774375037f662a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36043572ffb87cb4c9b37b54e1a48ff1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a36043572ffb87cb4c9b37b54e1a48ff1">current_size</a> () const noexcept override</td></tr>
<tr class="memdesc:a36043572ffb87cb4c9b37b54e1a48ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the semigroup that have been enumerated so far.  <a href="#a36043572ffb87cb4c9b37b54e1a48ff1">More...</a><br /></td></tr>
<tr class="separator:a36043572ffb87cb4c9b37b54e1a48ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5ab063b9bebe8fa214cc424587a5c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5ab063b9bebe8fa214cc424587a5c6">degree</a> () const noexcept override</td></tr>
<tr class="memdesc:adc5ab063b9bebe8fa214cc424587a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of any (and all) <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>'s in the semigroup.  <a href="#adc5ab063b9bebe8fa214cc424587a5c6">More...</a><br /></td></tr>
<tr class="separator:adc5ab063b9bebe8fa214cc424587a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf2803e182aed6fbbb9a0b392d92316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7cf2803e182aed6fbbb9a0b392d92316">end</a> () const</td></tr>
<tr class="memdesc:a7cf2803e182aed6fbbb9a0b392d92316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to one past the last currently known element of the semigroup.  <a href="#a7cf2803e182aed6fbbb9a0b392d92316">More...</a><br /></td></tr>
<tr class="separator:a7cf2803e182aed6fbbb9a0b392d92316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5e3d6358f5011c8fcefd59c42fca2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5e3d6358f5011c8fcefd59c42fca2f">enumerate</a> (size_t=LIMIT_MAX) override</td></tr>
<tr class="memdesc:adc5e3d6358f5011c8fcefd59c42fca2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the semigroup until <code>limit</code> elements are found or <code>killed</code> is <code>true</code>.  <a href="#adc5e3d6358f5011c8fcefd59c42fca2f">More...</a><br /></td></tr>
<tr class="separator:adc5e3d6358f5011c8fcefd59c42fca2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa83e5e0ab5bad64db7efabe6b6f3689"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#afa83e5e0ab5bad64db7efabe6b6f3689">equal_to</a> (<a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;, <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;) const override</td></tr>
<tr class="memdesc:afa83e5e0ab5bad64db7efabe6b6f3689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the parameters represent the same element of the semigroup and <code>false</code> otherwise.  <a href="#afa83e5e0ab5bad64db7efabe6b6f3689">More...</a><br /></td></tr>
<tr class="separator:afa83e5e0ab5bad64db7efabe6b6f3689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48be964090f90f5523d4d4a52b7333e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae48be964090f90f5523d4d4a52b7333e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae48be964090f90f5523d4d4a52b7333e">factorisation</a> (<a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a> const &amp;x)</td></tr>
<tr class="memdesc:ae48be964090f90f5523d4d4a52b7333e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to <code>x</code>.  <a href="#ae48be964090f90f5523d4d4a52b7333e">More...</a><br /></td></tr>
<tr class="separator:ae48be964090f90f5523d4d4a52b7333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474b1533a0b0a28a9bc4e4e6e4bd7d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a474b1533a0b0a28a9bc4e4e6e4bd7d6a">factorisation</a> (<a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> &amp;, element_index_type) override</td></tr>
<tr class="memdesc:a474b1533a0b0a28a9bc4e4e6e4bd7d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes <code>word</code> in-place to contain a word in the generators equal to the <code>pos</code> element of the semigroup.  <a href="#a474b1533a0b0a28a9bc4e4e6e4bd7d6a">More...</a><br /></td></tr>
<tr class="separator:a474b1533a0b0a28a9bc4e4e6e4bd7d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b43f8e52fb8b0a0c82f3e8ff07a4dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad0b43f8e52fb8b0a0c82f3e8ff07a4dc">factorisation</a> (element_index_type pos) override</td></tr>
<tr class="memdesc:ad0b43f8e52fb8b0a0c82f3e8ff07a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>.  <a href="#ad0b43f8e52fb8b0a0c82f3e8ff07a4dc">More...</a><br /></td></tr>
<tr class="separator:ad0b43f8e52fb8b0a0c82f3e8ff07a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a496d549156a988778b7a239ca31bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a9a496d549156a988778b7a239ca31bf4">factorisation</a> (const_reference)</td></tr>
<tr class="memdesc:a9a496d549156a988778b7a239ca31bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to <code>x</code>.  <a href="#a9a496d549156a988778b7a239ca31bf4">More...</a><br /></td></tr>
<tr class="separator:a9a496d549156a988778b7a239ca31bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38edd613f421b9811558c9e1ee1aebc7"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a38edd613f421b9811558c9e1ee1aebc7">fast_product</a> (element_index_type, element_index_type) const override</td></tr>
<tr class="memdesc:a38edd613f421b9811558c9e1ee1aebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code>.  <a href="#a38edd613f421b9811558c9e1ee1aebc7">More...</a><br /></td></tr>
<tr class="separator:a38edd613f421b9811558c9e1ee1aebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ee9cbfcca17b7ea551afdc33589267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad2ee9cbfcca17b7ea551afdc33589267">final_letter</a> (element_index_type pos) const override</td></tr>
<tr class="memdesc:ad2ee9cbfcca17b7ea551afdc33589267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last letter of the element in position <code>pos</code>.  <a href="#ad2ee9cbfcca17b7ea551afdc33589267">More...</a><br /></td></tr>
<tr class="separator:ad2ee9cbfcca17b7ea551afdc33589267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbbdbe9438eee4aa6e953fcde6a7b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#addbbdbe9438eee4aa6e953fcde6a7b8d">first_letter</a> (element_index_type pos) const override</td></tr>
<tr class="memdesc:addbbdbe9438eee4aa6e953fcde6a7b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first letter of the element in position <code>pos</code>.  <a href="#addbbdbe9438eee4aa6e953fcde6a7b8d">More...</a><br /></td></tr>
<tr class="separator:addbbdbe9438eee4aa6e953fcde6a7b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97210d28b09d11ffce68c29044063d5c"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a97210d28b09d11ffce68c29044063d5c">generator</a> (<a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>) const</td></tr>
<tr class="memdesc:a97210d28b09d11ffce68c29044063d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the generator with index <code>pos</code>.  <a href="#a97210d28b09d11ffce68c29044063d5c">More...</a><br /></td></tr>
<tr class="separator:a97210d28b09d11ffce68c29044063d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc730ee9c1c395f798fcdb2ef8820a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aebc730ee9c1c395f798fcdb2ef8820a1">is_idempotent</a> (element_index_type) override</td></tr>
<tr class="memdesc:aebc730ee9c1c395f798fcdb2ef8820a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the element in position <code>pos</code> is an idempotent and <code>false</code> if it is not.  <a href="#aebc730ee9c1c395f798fcdb2ef8820a1">More...</a><br /></td></tr>
<tr class="separator:aebc730ee9c1c395f798fcdb2ef8820a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771798b10a3724b2085198fc5c04598e"><td class="memItemLeft" align="right" valign="top"><a id="a771798b10a3724b2085198fc5c04598e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_monoid</b> () override</td></tr>
<tr class="separator:a771798b10a3724b2085198fc5c04598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357292be3b90ba4169ec9893b207c81"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae357292be3b90ba4169ec9893b207c81">left</a> (element_index_type, <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>) override</td></tr>
<tr class="memdesc:ae357292be3b90ba4169ec9893b207c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the product of the generator with index <code>j</code> and the element in position <code>i</code>.  <a href="#ae357292be3b90ba4169ec9893b207c81">More...</a><br /></td></tr>
<tr class="separator:ae357292be3b90ba4169ec9893b207c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac531f191e24219771f913b336916c95b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac531f191e24219771f913b336916c95b">length_const</a> (element_index_type) const override</td></tr>
<tr class="memdesc:ac531f191e24219771f913b336916c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the element in position <code>pos</code> of the semigroup.  <a href="#ac531f191e24219771f913b336916c95b">More...</a><br /></td></tr>
<tr class="separator:ac531f191e24219771f913b336916c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7e05b9facc3fb71037ead65ae245b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aae7e05b9facc3fb71037ead65ae245b6">length_non_const</a> (element_index_type) override</td></tr>
<tr class="memdesc:aae7e05b9facc3fb71037ead65ae245b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the element in position <code>pos</code> of the semigroup.  <a href="#aae7e05b9facc3fb71037ead65ae245b6">More...</a><br /></td></tr>
<tr class="separator:aae7e05b9facc3fb71037ead65ae245b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b152c493a7a8a37a4301a2ed74aeee"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a17b152c493a7a8a37a4301a2ed74aeee">letter_to_pos</a> (<a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>) const override</td></tr>
<tr class="memdesc:a17b152c493a7a8a37a4301a2ed74aeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in <code>this</code> of the generator with index <code>i</code>.  <a href="#a17b152c493a7a8a37a4301a2ed74aeee">More...</a><br /></td></tr>
<tr class="separator:a17b152c493a7a8a37a4301a2ed74aeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b8c86827687805d830684c4cfdf96d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a60b8c86827687805d830684c4cfdf96d">max_threads</a> () const noexcept override</td></tr>
<tr class="memdesc:a60b8c86827687805d830684c4cfdf96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of.  <a href="#a60b8c86827687805d830684c4cfdf96d">More...</a><br /></td></tr>
<tr class="separator:a60b8c86827687805d830684c4cfdf96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9833f76f7b7e83d381c2a43e2d30d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ab9833f76f7b7e83d381c2a43e2d30d99">minimal_factorisation</a> (<a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> &amp;, element_index_type) override</td></tr>
<tr class="memdesc:ab9833f76f7b7e83d381c2a43e2d30d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes <code>word</code> in-place to contain a minimal word with respect to the short-lex ordering in the generators equal to the <code>pos</code> element of the semigroup.  <a href="#ab9833f76f7b7e83d381c2a43e2d30d99">More...</a><br /></td></tr>
<tr class="separator:ab9833f76f7b7e83d381c2a43e2d30d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1b09e5070e36b0bf6e7b74f9195856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#afc1b09e5070e36b0bf6e7b74f9195856">minimal_factorisation</a> (element_index_type) override</td></tr>
<tr class="memdesc:afc1b09e5070e36b0bf6e7b74f9195856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimal <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>.  <a href="#afc1b09e5070e36b0bf6e7b74f9195856">More...</a><br /></td></tr>
<tr class="separator:afc1b09e5070e36b0bf6e7b74f9195856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ed8124ca1ec569613cb9a4ebb86b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a72ed8124ca1ec569613cb9a4ebb86b43">minimal_factorisation</a> (const_reference)</td></tr>
<tr class="memdesc:a72ed8124ca1ec569613cb9a4ebb86b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimal <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to <code>x</code>.  <a href="#a72ed8124ca1ec569613cb9a4ebb86b43">More...</a><br /></td></tr>
<tr class="separator:a72ed8124ca1ec569613cb9a4ebb86b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d1b8bbb713d52bd72e1d085b6d1370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac8d1b8bbb713d52bd72e1d085b6d1370">next_relation</a> (<a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> &amp;relation) override</td></tr>
<tr class="memdesc:ac8d1b8bbb713d52bd72e1d085b6d1370"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method changes <code>relation</code> in-place to contain the next relation of the presentation defining <code>this</code>.  <a href="#ac8d1b8bbb713d52bd72e1d085b6d1370">More...</a><br /></td></tr>
<tr class="separator:ac8d1b8bbb713d52bd72e1d085b6d1370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8957d580797dcbac29ccf209c4424c68"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8957d580797dcbac29ccf209c4424c68">nr_generators</a> () const noexcept override</td></tr>
<tr class="memdesc:a8957d580797dcbac29ccf209c4424c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generators of the semigroup.  <a href="#a8957d580797dcbac29ccf209c4424c68">More...</a><br /></td></tr>
<tr class="separator:a8957d580797dcbac29ccf209c4424c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764b475c8b4739d2457e287cf3b26fbe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a764b475c8b4739d2457e287cf3b26fbe">nr_idempotents</a> () override</td></tr>
<tr class="memdesc:a764b475c8b4739d2457e287cf3b26fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of idempotents in the semigroup.  <a href="#a764b475c8b4739d2457e287cf3b26fbe">More...</a><br /></td></tr>
<tr class="separator:a764b475c8b4739d2457e287cf3b26fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e4a47614e66e635263013841457454"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af5e4a47614e66e635263013841457454">nr_rules</a> () override</td></tr>
<tr class="memdesc:af5e4a47614e66e635263013841457454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of relations in the presentation defining the semigroup.  <a href="#af5e4a47614e66e635263013841457454">More...</a><br /></td></tr>
<tr class="separator:af5e4a47614e66e635263013841457454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc0a7d8cec826a413e366d84a70b710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a4dc0a7d8cec826a413e366d84a70b710">operator=</a> (<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> const &amp;semigroup)=delete</td></tr>
<tr class="memdesc:a4dc0a7d8cec826a413e366d84a70b710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="#a4dc0a7d8cec826a413e366d84a70b710">More...</a><br /></td></tr>
<tr class="separator:a4dc0a7d8cec826a413e366d84a70b710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef72a816855599c4a65aaeb0d3ccc2bb"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aef72a816855599c4a65aaeb0d3ccc2bb">operator[]</a> (element_index_type) const</td></tr>
<tr class="memdesc:aef72a816855599c4a65aaeb0d3ccc2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element of the semigroup in position <code>pos</code>.  <a href="#aef72a816855599c4a65aaeb0d3ccc2bb">More...</a><br /></td></tr>
<tr class="separator:aef72a816855599c4a65aaeb0d3ccc2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59c62785dc2ff194c5cc80c41d6cd6"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a0e59c62785dc2ff194c5cc80c41d6cd6">position</a> (const_reference)</td></tr>
<tr class="memdesc:a0e59c62785dc2ff194c5cc80c41d6cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of <code>x</code> in <code>this</code>, or FroidurePin::UNDEFINED if <code>x</code> is not an element of <code>this</code>.  <a href="#a0e59c62785dc2ff194c5cc80c41d6cd6">More...</a><br /></td></tr>
<tr class="separator:a0e59c62785dc2ff194c5cc80c41d6cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ac9a1b71e0a93e210e6a4bfbaaa508"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a26ac9a1b71e0a93e210e6a4bfbaaa508">position_to_sorted_position</a> (element_index_type) override</td></tr>
<tr class="memdesc:a26ac9a1b71e0a93e210e6a4bfbaaa508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of <code>this-&gt;at(pos)</code> in the sorted array of elements of the semigroup, or FroidurePin::UNDEFINED if <code>pos</code> is greater than the size of the semigroup.  <a href="#a26ac9a1b71e0a93e210e6a4bfbaaa508">More...</a><br /></td></tr>
<tr class="separator:a26ac9a1b71e0a93e210e6a4bfbaaa508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e19cb1cd60cb19c952155c3a69c486b"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a4e19cb1cd60cb19c952155c3a69c486b">prefix</a> (element_index_type pos) const override</td></tr>
<tr class="memdesc:a4e19cb1cd60cb19c952155c3a69c486b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the prefix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>.  <a href="#a4e19cb1cd60cb19c952155c3a69c486b">More...</a><br /></td></tr>
<tr class="separator:a4e19cb1cd60cb19c952155c3a69c486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56819977d388c7204f100850efa8a9f"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af56819977d388c7204f100850efa8a9f">product_by_reduction</a> (element_index_type, element_index_type) const override</td></tr>
<tr class="memdesc:af56819977d388c7204f100850efa8a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code> by following a path in the Cayley graph.  <a href="#af56819977d388c7204f100850efa8a9f">More...</a><br /></td></tr>
<tr class="separator:af56819977d388c7204f100850efa8a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3075dd5bd843e43f1b5ce2ccda40a77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a3075dd5bd843e43f1b5ce2ccda40a77a">reserve</a> (size_t) override</td></tr>
<tr class="memdesc:a3075dd5bd843e43f1b5ce2ccda40a77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the capacity (i.e. number of elements) of the semigroup be at least enough to contain n elements.  <a href="#a3075dd5bd843e43f1b5ce2ccda40a77a">More...</a><br /></td></tr>
<tr class="separator:a3075dd5bd843e43f1b5ce2ccda40a77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f9d80e0a0cfd602ad835d1cf20ebca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a41f9d80e0a0cfd602ad835d1cf20ebca">reset_next_relation</a> () noexcept override</td></tr>
<tr class="memdesc:a41f9d80e0a0cfd602ad835d1cf20ebca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resets <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac8d1b8bbb713d52bd72e1d085b6d1370" title="This method changes relation in-place to contain the next relation of the presentation defining this...">FroidurePin::next_relation</a> so that when it is next called the resulting relation is the first one.  <a href="#a41f9d80e0a0cfd602ad835d1cf20ebca">More...</a><br /></td></tr>
<tr class="separator:a41f9d80e0a0cfd602ad835d1cf20ebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317c01d4a2a0db764d2e505b14057917"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a317c01d4a2a0db764d2e505b14057917">right</a> (element_index_type, <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>) override</td></tr>
<tr class="memdesc:a317c01d4a2a0db764d2e505b14057917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the product of the element in position <code>i</code> with the generator with index <code>j</code>.  <a href="#a317c01d4a2a0db764d2e505b14057917">More...</a><br /></td></tr>
<tr class="separator:a317c01d4a2a0db764d2e505b14057917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3454f9ebf1e451f1d956da0a550d07"><td class="memItemLeft" align="right" valign="top"><a id="a3f3454f9ebf1e451f1d956da0a550d07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> () override</td></tr>
<tr class="separator:a3f3454f9ebf1e451f1d956da0a550d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617f46390660a1341ee2a1a60d995393"><td class="memItemLeft" align="right" valign="top"><a id="a617f46390660a1341ee2a1a60d995393"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> (size_t)</td></tr>
<tr class="separator:a617f46390660a1341ee2a1a60d995393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81169e9e015985bf7959c9aa5bef4a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a81169e9e015985bf7959c9aa5bef4a27">set_batch_size</a> (size_t) noexcept override</td></tr>
<tr class="memdesc:a81169e9e015985bf7959c9aa5bef4a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new value for the batch size.  <a href="#a81169e9e015985bf7959c9aa5bef4a27">More...</a><br /></td></tr>
<tr class="separator:a81169e9e015985bf7959c9aa5bef4a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac64640965625a67d2301b27b9401039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aac64640965625a67d2301b27b9401039">set_concurrency_threshold</a> (size_t) noexcept override</td></tr>
<tr class="memdesc:aac64640965625a67d2301b27b9401039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of.  <a href="#aac64640965625a67d2301b27b9401039">More...</a><br /></td></tr>
<tr class="separator:aac64640965625a67d2301b27b9401039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec2111e45f6eb680ea16d1f422b294c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7ec2111e45f6eb680ea16d1f422b294c">set_max_threads</a> (size_t) noexcept override</td></tr>
<tr class="memdesc:a7ec2111e45f6eb680ea16d1f422b294c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads that any method of an instance of <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> can use.  <a href="#a7ec2111e45f6eb680ea16d1f422b294c">More...</a><br /></td></tr>
<tr class="separator:a7ec2111e45f6eb680ea16d1f422b294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2b2470b22ebc3086cb2776d2aa8f1c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1d2b2470b22ebc3086cb2776d2aa8f1c">size</a> () override</td></tr>
<tr class="memdesc:a1d2b2470b22ebc3086cb2776d2aa8f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the semigroup.  <a href="#a1d2b2470b22ebc3086cb2776d2aa8f1c">More...</a><br /></td></tr>
<tr class="separator:a1d2b2470b22ebc3086cb2776d2aa8f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5704eea9805fc949f14ea8c2b9993a79"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a5704eea9805fc949f14ea8c2b9993a79">sorted_at</a> (element_index_type)</td></tr>
<tr class="memdesc:a5704eea9805fc949f14ea8c2b9993a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element of the semigroup in position <code>pos</code> of the sorted array of elements, or <code>nullptr</code> in <code>pos</code> is not valid (i.e. too big).  <a href="#a5704eea9805fc949f14ea8c2b9993a79">More...</a><br /></td></tr>
<tr class="separator:a5704eea9805fc949f14ea8c2b9993a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824ef2c3eb24c7fe799ebc9824a020a"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae824ef2c3eb24c7fe799ebc9824a020a">sorted_position</a> (const_reference)</td></tr>
<tr class="memdesc:ae824ef2c3eb24c7fe799ebc9824a020a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of <code>x</code> in the sorted array of elements of the semigroup, or FroidurePin::UNDEFINED if <code>x</code> is not an element of <code>this</code>.  <a href="#ae824ef2c3eb24c7fe799ebc9824a020a">More...</a><br /></td></tr>
<tr class="separator:ae824ef2c3eb24c7fe799ebc9824a020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dbe95a65c0a9f93a20813ff987fdae"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a97dbe95a65c0a9f93a20813ff987fdae">suffix</a> (element_index_type pos) const override</td></tr>
<tr class="memdesc:a97dbe95a65c0a9f93a20813ff987fdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the suffix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>.  <a href="#a97dbe95a65c0a9f93a20813ff987fdae">More...</a><br /></td></tr>
<tr class="separator:a97dbe95a65c0a9f93a20813ff987fdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4d105196420d362c76de79ec0bdf9"><td class="memItemLeft" align="right" valign="top">element_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af7c4d105196420d362c76de79ec0bdf9">word_to_element</a> (<a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;) const</td></tr>
<tr class="memdesc:af7c4d105196420d362c76de79ec0bdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the element of <code>this</code> represented by the word <code>w</code>.  <a href="#af7c4d105196420d362c76de79ec0bdf9">More...</a><br /></td></tr>
<tr class="separator:af7c4d105196420d362c76de79ec0bdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015df010853f76a36374d3859d481cbe"><td class="memItemLeft" align="right" valign="top">element_index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a015df010853f76a36374d3859d481cbe">word_to_pos</a> (<a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;) const override</td></tr>
<tr class="memdesc:a015df010853f76a36374d3859d481cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in the semigroup corresponding to the element represented by the word <code>w</code>.  <a href="#a015df010853f76a36374d3859d481cbe">More...</a><br /></td></tr>
<tr class="separator:a015df010853f76a36374d3859d481cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a474ca687fc189f1932b6f625e94ff724"><td class="memItemLeft" align="right" valign="top"><a id="a474ca687fc189f1932b6f625e94ff724"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_degree</b></td></tr>
<tr class="separator:a474ca687fc189f1932b6f625e94ff724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77602c8e8e29102f1616d8d6169f29d4"><td class="memItemLeft" align="right" valign="top"><a id="a77602c8e8e29102f1616d8d6169f29d4"></a>
std::vector&lt; std::pair&lt; <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>, <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_duplicate_gens</b></td></tr>
<tr class="separator:a77602c8e8e29102f1616d8d6169f29d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d5f9bf9db4aae5c87d10cc9f84ef65"><td class="memItemLeft" align="right" valign="top"><a id="a91d5f9bf9db4aae5c87d10cc9f84ef65"></a>
std::vector&lt; internal_element_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_elements</b></td></tr>
<tr class="separator:a91d5f9bf9db4aae5c87d10cc9f84ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bf56cadbba376150d399070b2674a4"><td class="memItemLeft" align="right" valign="top"><a id="ac0bf56cadbba376150d399070b2674a4"></a>
std::vector&lt; element_index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_enumerate_order</b></td></tr>
<tr class="separator:ac0bf56cadbba376150d399070b2674a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caf6ff83024ab78c4692168cc601d49"><td class="memItemLeft" align="right" valign="top"><a id="a0caf6ff83024ab78c4692168cc601d49"></a>
std::vector&lt; <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_final</b></td></tr>
<tr class="separator:a0caf6ff83024ab78c4692168cc601d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b70d7b08bec5ae0b69e18cbe73cb06e"><td class="memItemLeft" align="right" valign="top"><a id="a3b70d7b08bec5ae0b69e18cbe73cb06e"></a>
std::vector&lt; <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_first</b></td></tr>
<tr class="separator:a3b70d7b08bec5ae0b69e18cbe73cb06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e9b79fd4f86a41a6a6c978f3e64b78"><td class="memItemLeft" align="right" valign="top"><a id="ab6e9b79fd4f86a41a6a6c978f3e64b78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_found_one</b></td></tr>
<tr class="separator:ab6e9b79fd4f86a41a6a6c978f3e64b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6649ae3d20ebec0ab282ec1c225d2"><td class="memItemLeft" align="right" valign="top"><a id="a7ff6649ae3d20ebec0ab282ec1c225d2"></a>
std::vector&lt; internal_element_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_gens</b></td></tr>
<tr class="separator:a7ff6649ae3d20ebec0ab282ec1c225d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ef8f7ae6d3e1ea4042cacc824a23ef"><td class="memItemLeft" align="right" valign="top"><a id="ab1ef8f7ae6d3e1ea4042cacc824a23ef"></a>
internal_element_type&#160;</td><td class="memItemRight" valign="bottom"><b>_id</b></td></tr>
<tr class="separator:ab1ef8f7ae6d3e1ea4042cacc824a23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343fc55a0ea6689ece105e5d72086bf9"><td class="memItemLeft" align="right" valign="top"><a id="a343fc55a0ea6689ece105e5d72086bf9"></a>
std::vector&lt; internal_idempotent_pair &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_idempotents</b></td></tr>
<tr class="separator:a343fc55a0ea6689ece105e5d72086bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96d06e5b930497255c0ce96e2aa0a9"><td class="memItemLeft" align="right" valign="top"><a id="a9a96d06e5b930497255c0ce96e2aa0a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_idempotents_found</b></td></tr>
<tr class="separator:a9a96d06e5b930497255c0ce96e2aa0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0d9339c04b643ced87d4ef375d2b5c"><td class="memItemLeft" align="right" valign="top"><a id="a5a0d9339c04b643ced87d4ef375d2b5c"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_is_idempotent</b></td></tr>
<tr class="separator:a5a0d9339c04b643ced87d4ef375d2b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab366e3532cb624c1749c1af23cc509cb"><td class="memItemLeft" align="right" valign="top"><a id="ab366e3532cb624c1749c1af23cc509cb"></a>
cayley_graph_type&#160;</td><td class="memItemRight" valign="bottom"><b>_left</b></td></tr>
<tr class="separator:ab366e3532cb624c1749c1af23cc509cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b750d5deb4c00e9963202aaa76a0a79"><td class="memItemLeft" align="right" valign="top"><a id="a0b750d5deb4c00e9963202aaa76a0a79"></a>
std::vector&lt; size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_length</b></td></tr>
<tr class="separator:a0b750d5deb4c00e9963202aaa76a0a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e010fd3e1ba849115ef7ecd2eac69d4"><td class="memItemLeft" align="right" valign="top"><a id="a3e010fd3e1ba849115ef7ecd2eac69d4"></a>
std::vector&lt; enumerate_index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_lenindex</b></td></tr>
<tr class="separator:a3e010fd3e1ba849115ef7ecd2eac69d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54361fef0ecb447e00ff311834eeda5f"><td class="memItemLeft" align="right" valign="top"><a id="a54361fef0ecb447e00ff311834eeda5f"></a>
std::vector&lt; element_index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_letter_to_pos</b></td></tr>
<tr class="separator:a54361fef0ecb447e00ff311834eeda5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7596d32ecff7167987f94b6075df66ba"><td class="memItemLeft" align="right" valign="top"><a id="a7596d32ecff7167987f94b6075df66ba"></a>
std::unordered_map&lt; internal_const_element_type, element_index_type, internal_hash, internal_equal_to &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_map</b></td></tr>
<tr class="separator:a7596d32ecff7167987f94b6075df66ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700b8934d7ee4389ae24cef17eed3173"><td class="memItemLeft" align="right" valign="top"><a id="a700b8934d7ee4389ae24cef17eed3173"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>_mtx</b></td></tr>
<tr class="separator:a700b8934d7ee4389ae24cef17eed3173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5f8d2897d1a9a37c5caaf67738924e"><td class="memItemLeft" align="right" valign="top"><a id="a8e5f8d2897d1a9a37c5caaf67738924e"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>_nr</b></td></tr>
<tr class="separator:a8e5f8d2897d1a9a37c5caaf67738924e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13fdd7011d78403d774e68a3f24b30a"><td class="memItemLeft" align="right" valign="top"><a id="aa13fdd7011d78403d774e68a3f24b30a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_nr_rules</b></td></tr>
<tr class="separator:aa13fdd7011d78403d774e68a3f24b30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a494d2394d6d5891839889cdb2b7050"><td class="memItemLeft" align="right" valign="top"><a id="a5a494d2394d6d5891839889cdb2b7050"></a>
<a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_nrgens</b></td></tr>
<tr class="separator:a5a494d2394d6d5891839889cdb2b7050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0485166d3c70ccb65916aff0e4c90c02"><td class="memItemLeft" align="right" valign="top"><a id="a0485166d3c70ccb65916aff0e4c90c02"></a>
enumerate_index_type&#160;</td><td class="memItemRight" valign="bottom"><b>_pos</b></td></tr>
<tr class="separator:a0485166d3c70ccb65916aff0e4c90c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f077dff4c130193b847b24b62047ba"><td class="memItemLeft" align="right" valign="top"><a id="aa5f077dff4c130193b847b24b62047ba"></a>
element_index_type&#160;</td><td class="memItemRight" valign="bottom"><b>_pos_one</b></td></tr>
<tr class="separator:aa5f077dff4c130193b847b24b62047ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1492a2fae05873c5fc4679988883f440"><td class="memItemLeft" align="right" valign="top"><a id="a1492a2fae05873c5fc4679988883f440"></a>
std::vector&lt; element_index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_prefix</b></td></tr>
<tr class="separator:a1492a2fae05873c5fc4679988883f440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d1d495fa367f399760298628484230"><td class="memItemLeft" align="right" valign="top"><a id="a09d1d495fa367f399760298628484230"></a>
internal::RecVec&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_reduced</b></td></tr>
<tr class="separator:a09d1d495fa367f399760298628484230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9989007858c247933605967a4d3f184c"><td class="memItemLeft" align="right" valign="top"><a id="a9989007858c247933605967a4d3f184c"></a>
<a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_relation_gen</b></td></tr>
<tr class="separator:a9989007858c247933605967a4d3f184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027e99243256b0671cc14e03c8a3fe3"><td class="memItemLeft" align="right" valign="top"><a id="a6027e99243256b0671cc14e03c8a3fe3"></a>
enumerate_index_type&#160;</td><td class="memItemRight" valign="bottom"><b>_relation_pos</b></td></tr>
<tr class="separator:a6027e99243256b0671cc14e03c8a3fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33100b866d24b81ad5cb5c3946e2c5"><td class="memItemLeft" align="right" valign="top"><a id="a8b33100b866d24b81ad5cb5c3946e2c5"></a>
cayley_graph_type&#160;</td><td class="memItemRight" valign="bottom"><b>_right</b></td></tr>
<tr class="separator:a8b33100b866d24b81ad5cb5c3946e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dacade9a4cd9fd3e68a2e1047bafdb"><td class="memItemLeft" align="right" valign="top"><a id="ab2dacade9a4cd9fd3e68a2e1047bafdb"></a>
struct libsemigroups::FroidurePin::Settings&#160;</td><td class="memItemRight" valign="bottom"><b>_settings</b></td></tr>
<tr class="separator:ab2dacade9a4cd9fd3e68a2e1047bafdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2258833e9d5900aad3fcd2e5d4437f"><td class="memItemLeft" align="right" valign="top"><a id="aab2258833e9d5900aad3fcd2e5d4437f"></a>
std::vector&lt; std::pair&lt; internal_element_type, element_index_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_sorted</b></td></tr>
<tr class="separator:aab2258833e9d5900aad3fcd2e5d4437f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d3aa5f3d0d953c58efabcce81baba3"><td class="memItemLeft" align="right" valign="top"><a id="a25d3aa5f3d0d953c58efabcce81baba3"></a>
std::vector&lt; element_index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_suffix</b></td></tr>
<tr class="separator:a25d3aa5f3d0d953c58efabcce81baba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f15b6a5bc74ad9c943ef500e48e9a0"><td class="memItemLeft" align="right" valign="top"><a id="a22f15b6a5bc74ad9c943ef500e48e9a0"></a>
internal_element_type&#160;</td><td class="memItemRight" valign="bottom"><b>_tmp_product</b></td></tr>
<tr class="separator:a22f15b6a5bc74ad9c943ef500e48e9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7afc7586a8357b0aad71fb65e1d24b6"><td class="memItemLeft" align="right" valign="top"><a id="ad7afc7586a8357b0aad71fb65e1d24b6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_wordlen</b></td></tr>
<tr class="separator:ad7afc7586a8357b0aad71fb65e1d24b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TElementType = Element const*, typename TElementHash = internal::hash&lt;TElementType&gt;, typename TElementEqual = internal::equal_to&lt;TElementType&gt;, class TTraits = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt;<br />
class libsemigroups::FroidurePin&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;</h3>

<p>Class for semigroups generated by instances of <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>. </p>
<p>FroidurePins are defined by a generating set, and the main method here is <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5e3d6358f5011c8fcefd59c42fca2f" title="Enumerate the semigroup until limit elements are found or killed is true. ">FroidurePin::enumerate</a>, which implements the <a href="https://www.irif.fr/~jep/PDF/Rio.pdf">Froidure-Pin Algorithm</a>. When the enumeration of the semigroup is complete, the size, the left and right Cayley graphs are determined, and a confluent terminating presentation for the semigroup is known. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a95514b17592385e49be35b4a08a5c7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95514b17592385e49be35b4a08a5c7b4">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> =  internal::iterator_base&lt;internal_element_type, const_pointer, const_reference, element_type, iterator_methods&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for const iterators through the elements of <code>this</code>, in the order they were enumerated (i.e. in short-lex order of the minimum word in the generators of <code>this</code> equal to any given element). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1" title="A type for const reverse iterators through the elements of this, in the reverse order of enumeration...">const_reverse_iterator</a>. </dd></dl>

</div>
</div>
<a id="ad7b4bc2ed33c1888222bbb7012850593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b4bc2ed33c1888222bbb7012850593">&#9670;&nbsp;</a></span>const_iterator_idempotents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593">const_iterator_idempotents</a> =  const_iterator_pair_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for const iterators through the idempotents of <code>this</code>, in short-lex order. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4" title="A type for const iterators through the elements of this, in the order they were enumerated (i...">const_iterator</a>. </dd></dl>

</div>
</div>
<a id="a1b25fb1414699d00d393cf1b263e4c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b25fb1414699d00d393cf1b263e4c5d">&#9670;&nbsp;</a></span>const_iterator_sorted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d">const_iterator_sorted</a> =  const_iterator_pair_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for const iterators through the elements of <code>this</code>, sorted according to TTraits::less. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3" title="A type for const reverse iterators through the elements of this, sorted according to TTraits::less...">const_reverse_iterator_sorted</a>. </dd></dl>

</div>
</div>
<a id="a8bbeec3bafafb5f03e6c3e367fa46fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbeec3bafafb5f03e6c3e367fa46fd1">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for const reverse iterators through the elements of <code>this</code>, in the reverse order of enumeration. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4" title="A type for const iterators through the elements of this, in the order they were enumerated (i...">const_iterator</a>. </dd></dl>

</div>
</div>
<a id="ae7a3e00b4dad5fbf1d3c151ef3ffaae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a3e00b4dad5fbf1d3c151ef3ffaae8">&#9670;&nbsp;</a></span>const_reverse_iterator_idempotents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae7a3e00b4dad5fbf1d3c151ef3ffaae8">const_reverse_iterator_idempotents</a> =  const_reverse_iterator_pair_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for reverse const iterators through the idempotents of <code>this</code>, in short-lex order. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593" title="A type for const iterators through the idempotents of this, in short-lex order. ">const_iterator_idempotents</a>. </dd></dl>

</div>
</div>
<a id="aece8d9dcc0c9eadd25e6e3d8eef032e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece8d9dcc0c9eadd25e6e3d8eef032e3">&#9670;&nbsp;</a></span>const_reverse_iterator_sorted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3">const_reverse_iterator_sorted</a> =  const_reverse_iterator_pair_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for const reverse iterators through the elements of <code>this</code>, sorted according to TTraits::less. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d" title="A type for const iterators through the elements of this, sorted according to TTraits::less. ">const_iterator_sorted</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f429294dce44f883223135c7ff41d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f429294dce44f883223135c7ff41d33">&#9670;&nbsp;</a></span>FroidurePin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; element_type &gt; const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from generators. </p>
<p>This is the default constructor for a semigroup generated by <code>gens</code>. The generators <code>gens</code> must all be of the same derived subclass of the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> base class. Additionally, <code>gens</code> must satisfy the following:</p>
<ol type="1">
<li>there must be at least one generator</li>
<li>the generators must have equal degree <a class="el" href="classlibsemigroups_1_1_element.html#a737a5e72977f33f609b0e6f63032a5f2" title="Returns the degree of an Element. ">Element::degree</a> if either of these points is not satisfied, then a LIBSEMIGROUPS_EXCEPTION will be thrown.</li>
</ol>
<p>There can be duplicate generators and although they do not count as distinct elements, they do count as distinct generators. In other words, the generators of the semigroup are precisely (a copy of) <code>gens</code> in the same order they occur in <code>gens</code>.</p>
<p>The generators <code>gens</code> are copied by the constructor, and so it is the responsibility of the caller to delete <code>gens</code>. </p>

</div>
</div>
<a id="a1d7bb7a6bdfa1a4e2d3848e6d7a1e768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7bb7a6bdfa1a4e2d3848e6d7a1e768">&#9670;&nbsp;</a></span>FroidurePin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; element_type &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from generators. </p>
<p>This constructor simply calls the above constructor with a pointer to <code>gens</code>. </p>

</div>
</div>
<a id="a3240cb7c614710898be33b7143133842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3240cb7c614710898be33b7143133842">&#9670;&nbsp;</a></span>FroidurePin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; element_type &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from generators. </p>
<p>This constructor simply constructs a vector from <code>gens</code> and calls the above constructor. </p>

</div>
</div>
<a id="ae65786861e9c2b49618980887ad312ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65786861e9c2b49618980887ad312ab">&#9670;&nbsp;</a></span>FroidurePin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs a new <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> which is an exact copy of <code>copy</code>. No enumeration is triggered for either <code>copy</code> or of the newly constructed semigroup. </p>

</div>
</div>
<a id="a41031b82ab19bc8ae5be89e71e7e113c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41031b82ab19bc8ae5be89e71e7e113c">&#9670;&nbsp;</a></span>~FroidurePin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::~<a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5beea877d9d37caaf2f6406456c9231a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beea877d9d37caaf2f6406456c9231a">&#9670;&nbsp;</a></span>add_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::add_generator </td>
          <td>(</td>
          <td class="paramtype">element_type const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the generators <code>coll</code> to the generators of <code>this</code>. </p>
<p>This method can be used to add new generators to the existing semigroup in such a way that any previously enumerated data is preserved and not recomputed, or copied. This can be faster than recomputing the semigroup generated by the old generators and the new generators in the parameter <code>coll</code>.</p>
<p>This method changes the semigroup in-place, thereby invalidating possibly previously known data about the semigroup, such as the left or right Cayley graphs, number of idempotents, and so on.</p>
<p>Every generator in <code>coll</code> is added regardless of whether or not it is already a generator or element of the semigroup (it may belong to the semigroup but just not be known to belong). If <code>coll</code> is empty, then the semigroup is left unchanged. The order the generators is added is also the order they occur in the parameter <code>coll</code>.</p>
<p>The semigroup is returned in a state where all of the previously enumerated elements which had been multiplied by all of the old generators, have now been multiplied by all of the old and new generators. This means that after this method is called the semigroup might contain many more elements than before (whether it is fully enumerating or not). It can also be the case that the new generators are the only new elements, unlike, say, in the case of non-trivial groups.</p>
<p>The elements of the argument <code>coll</code> are copied into the semigroup, and should be deleted by the caller. If an element in <code>coll</code> has a degree different to <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5ab063b9bebe8fa214cc424587a5c6" title="Returns the degree of any (and all) Element&#39;s in the semigroup. ">degree()</a></code>, a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="af6f322722ac56a1ae74b236f25dd5c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f322722ac56a1ae74b236f25dd5c3b">&#9670;&nbsp;</a></span>add_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::add_generators </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const_element_type &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the generators <code>coll</code> to the generators of <code>this</code>. </p>
<p>See FroidurePin::add_generators for more details. </p>

</div>
</div>
<a id="a7272ba920f61eb20fdaad08e25e0ca8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7272ba920f61eb20fdaad08e25e0ca8a">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::at </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element of the semigroup in position <code>pos</code>, or a <code>nullptr</code> if there is no such element. </p>
<p>This method attempts to enumerate the semigroup until at least <code>pos</code> + 1 elements have been found. If <code>pos</code> is greater than <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1d2b2470b22ebc3086cb2776d2aa8f1c" title="Returns the size of the semigroup. ">FroidurePin::size</a>, then this method returns <code>nullptr</code>. </p>

</div>
</div>
<a id="afdea8a2639f0ef0f27f1a56a1b1dc31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdea8a2639f0ef0f27f1a56a1b1dc31b">&#9670;&nbsp;</a></span>batch_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::batch_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value of the batch size. This is the minimum number of elements enumerated in any call to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5e3d6358f5011c8fcefd59c42fca2f" title="Enumerate the semigroup until limit elements are found or killed is true. ">FroidurePin::enumerate</a>. </p>

</div>
</div>
<a id="a4729e02da96b8d94b94305eda21e01c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4729e02da96b8d94b94305eda21e01c1">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to the first element of the semigroup. </p>
<p>This method does not perform any enumeration of the semigroup, the iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a6150d15a31a7d49864cf33a68a612ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6150d15a31a7d49864cf33a68a612ead">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to the first element of the semigroup. </p>
<p>This method does not perform any enumeration of the semigroup, the iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a1ed153f10e29c866569a0e4bbf57ec5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed153f10e29c866569a0e4bbf57ec5b">&#9670;&nbsp;</a></span>cbegin_idempotents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593">const_iterator_idempotents</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::cbegin_idempotents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing at the first idempotent in the semigroup. </p>
<p>If the returned iterator is incremented, then it points to the second idempotent in the semigroup (if it exists), and every subsequent increment points to the next idempotent.</p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. </p>

</div>
</div>
<a id="a2df3a8c3a80702bede19a3813897880a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df3a8c3a80702bede19a3813897880a">&#9670;&nbsp;</a></span>cbegin_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d">const_iterator_sorted</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::cbegin_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to the first element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>. </p>
<p>This method fully enumerates the semigroup, the returned iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a554cea35b83f0f43e9afa40fcab564ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554cea35b83f0f43e9afa40fcab564ba">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to one past the last currently known element of the semigroup. </p>
<p>This method does not perform any enumeration of the semigroup, the iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="af3a567f5dfd52d56da97368478a10dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a567f5dfd52d56da97368478a10dbc">&#9670;&nbsp;</a></span>cend_idempotents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad7b4bc2ed33c1888222bbb7012850593">const_iterator_idempotents</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::cend_idempotents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator referring to past the end of the last idempotent in the semigroup. </p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. </p>

</div>
</div>
<a id="a6c4602d52957b4b6720e84db2ff8ee64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4602d52957b4b6720e84db2ff8ee64">&#9670;&nbsp;</a></span>cend_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a1b25fb1414699d00d393cf1b263e4c5d">const_iterator_sorted</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::cend_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to one past the last element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>. </p>
<p>This method fully enumerates the semigroup, the returned iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a5d183298c1674e99f4af25f507b9d88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d183298c1674e99f4af25f507b9d88b">&#9670;&nbsp;</a></span>closure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<div class="memtemplate">
template&lt;class TCollection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::closure </td>
          <td>(</td>
          <td class="paramtype">TCollection const &amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>. </p>
<p>This method can be used to add new generators to an existing semigroup in such a way that any previously enumerated data is preserved and not recomputed, or copied. This can be faster than recomputing the semigroup generated by the old generators and the new in <code>coll</code>.</p>
<p>This method differs from FroidurePin::add_generators in that it tries to add the new generators one by one, and only adds those generators that are not products of existing generators (including any new generators from <code>coll</code> that were added before). The generators are added in the order they occur in <code>coll</code>.</p>
<p>This method changes the semigroup in-place, thereby invalidating possibly previously known data about the semigroup, such as the left or right Cayley graphs, or number of idempotents, for example.</p>
<p>The elements the parameter <code>coll</code> are copied into the semigroup, and should be deleted by the caller. If an element in <code>coll</code> has a degree different to <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5ab063b9bebe8fa214cc424587a5c6" title="Returns the degree of any (and all) Element&#39;s in the semigroup. ">degree()</a></code>, a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="ae6ca700bd25d6c246c3beb119608e931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ca700bd25d6c246c3beb119608e931">&#9670;&nbsp;</a></span>closure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::closure </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const_element_type &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>. </p>
<p>See <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a5d183298c1674e99f4af25f507b9d88b" title="Add copies of the non-redundant generators in coll to the generators of this. ">FroidurePin::closure</a> for more details. </p>

</div>
</div>
<a id="afb734853b124748c84f2c1b34b3f729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb734853b124748c84f2c1b34b3f729f">&#9670;&nbsp;</a></span>concurrency_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::concurrency_threshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value of. </p>

</div>
</div>
<a id="a9aca6d89e44d8a97d7ed813ed3d12534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aca6d89e44d8a97d7ed813ed3d12534">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>x</code> is an element of <code>this</code> and <code>false</code> if it is not. </p>
<p>This method can be used to check if the element <code>x</code> is an element of the semigroup. The semigroup is enumerated in batches until <code>x</code> is found or the semigroup is fully enumerated but <code>x</code> was not found (see <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a81169e9e015985bf7959c9aa5bef4a27" title="Set a new value for the batch size. ">FroidurePin::set_batch_size</a>). </p>

</div>
</div>
<a id="a7b269953ddf51f27bc21d9e4c1872b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b269953ddf51f27bc21d9e4c1872b3b">&#9670;&nbsp;</a></span>copy_add_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<div class="memtemplate">
template&lt;class TCollection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a>* <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::copy_add_generators </td>
          <td>(</td>
          <td class="paramtype">TCollection const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new semigroup generated by <code>this</code> and <code>coll</code>. </p>
<p>This method is equivalent to copying <code>this</code> using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae65786861e9c2b49618980887ad312ab" title="Copy constructor. ">FroidurePin::FroidurePin(const FroidurePin&amp; copy)</a> and then calling FroidurePin::add_generators on the copy, but this method avoids copying the parts of <code>this</code> that are immediately invalidated by FroidurePin::add_generators.</p>
<p>The elements the argument <code>coll</code> are copied into the semigroup, and should be deleted by the caller. If an element in <code>coll</code> has a degree different to <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5ab063b9bebe8fa214cc424587a5c6" title="Returns the degree of any (and all) Element&#39;s in the semigroup. ">degree()</a></code>, a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="ac5545a82f9f79139ad74dc1049bbedc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5545a82f9f79139ad74dc1049bbedc8">&#9670;&nbsp;</a></span>copy_closure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<div class="memtemplate">
template&lt;class TCollection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a>* <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::copy_closure </td>
          <td>(</td>
          <td class="paramtype">TCollection const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new semigroup generated by <code>this</code> and copies of the non-redundant elements of <code>coll</code>. </p>
<p>This method is equivalent to copying <code>this</code> and then calling <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a5d183298c1674e99f4af25f507b9d88b" title="Add copies of the non-redundant generators in coll to the generators of this. ">FroidurePin::closure</a> on the copy with <code>coll</code>, but this method avoids copying the parts of <code>this</code> that are immediately invalidated by <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a5d183298c1674e99f4af25f507b9d88b" title="Add copies of the non-redundant generators in coll to the generators of this. ">FroidurePin::closure</a>.</p>
<p>The elements the argument <code>coll</code> are copied into the semigroup, and should be deleted by the caller. If an element in <code>coll</code> has a degree different to <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5ab063b9bebe8fa214cc424587a5c6" title="Returns the degree of any (and all) Element&#39;s in the semigroup. ">degree()</a></code>, a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="a0278707854105f166a5a3a1e075a214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0278707854105f166a5a3a1e075a214e">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1">const_reverse_iterator</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reverse iterator pointing to the last currently known element of the semigroup. </p>
<p>This method does not perform any enumeration of the semigroup, the iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a425e6689e5a51934de6e91ec0d4ea852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425e6689e5a51934de6e91ec0d4ea852">&#9670;&nbsp;</a></span>crbegin_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3">const_reverse_iterator_sorted</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::crbegin_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to the last element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>. </p>
<p>This method fully enumerates the semigroup, the returned iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a2cf4000e834607b00043249be0c6d882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf4000e834607b00043249be0c6d882">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8bbeec3bafafb5f03e6c3e367fa46fd1">const_reverse_iterator</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reverse iterator pointing to one before the first element of the semigroup. </p>
<p>This method does not perform any enumeration of the semigroup, the iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="aa198d7fda4568d5bf1187401357de4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa198d7fda4568d5bf1187401357de4dc">&#9670;&nbsp;</a></span>crend_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#aece8d9dcc0c9eadd25e6e3d8eef032e3">const_reverse_iterator_sorted</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::crend_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to one before the first element of the semigroup when the elements are sorted by <a class="el" href="classlibsemigroups_1_1_element.html#ab24e090bd9768f4301e29c21c55b5fd5" title="Returns true if this is less than that. ">Element::operator&lt;</a>. </p>
<p>This method fully enumerates the semigroup, the returned iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="a6f2044c9081774ce69b1ba9275d44119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2044c9081774ce69b1ba9275d44119">&#9670;&nbsp;</a></span>current_max_word_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::current_max_word_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum length of a word in the generators so far computed. </p>
<p>Every elements of the semigroup can be expressed as a product of the generators. The elements of the semigroup are enumerated in the short-lex order induced by the order of the generators (as passed to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a2f429294dce44f883223135c7ff41d33" title="Construct from generators. ">FroidurePin::FroidurePin</a>). This method returns the length of the longest word in the generators that has so far been enumerated. </p>

</div>
</div>
<a id="a543b9ffde8dbaf11c8562de69a02dd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543b9ffde8dbaf11c8562de69a02dd13">&#9670;&nbsp;</a></span>current_nr_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::current_nr_rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of relations in the presentation for the semigroup that have been found so far. </p>
<p>This is only the actual number of relations in a presentation defining the semigroup if the semigroup is fully enumerated. </p>

</div>
</div>
<a id="a7d51625044ad0c6ea774375037f662a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d51625044ad0c6ea774375037f662a9">&#9670;&nbsp;</a></span>current_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::current_position </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of the element <code>x</code> in the semigroup if it is already known to belong to the semigroup. </p>
<p>This method finds the position of the element <code>x</code> in the semigroup if it is already known to belong to the semigroup, and libsemigroups::FroidurePin::UNDEFINED if not. If the semigroup is not fully enumerated, then this method may return libsemigroups::FroidurePin::UNDEFINED when <code>x</code> is in the semigroup, but this is not yet known.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a0e59c62785dc2ff194c5cc80c41d6cd6" title="Returns the position of x in this, or FroidurePin::UNDEFINED if x is not an element of this...">FroidurePin::position</a> and <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ae824ef2c3eb24c7fe799ebc9824a020a" title="Returns the position of x in the sorted array of elements of the semigroup, or FroidurePin::UNDEFINED...">FroidurePin::sorted_position</a>. </dd></dl>

</div>
</div>
<a id="a36043572ffb87cb4c9b37b54e1a48ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36043572ffb87cb4c9b37b54e1a48ff1">&#9670;&nbsp;</a></span>current_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::current_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the semigroup that have been enumerated so far. </p>
<p>This is only the actual size of the semigroup if the semigroup is fully enumerated. </p>

</div>
</div>
<a id="adc5ab063b9bebe8fa214cc424587a5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5ab063b9bebe8fa214cc424587a5c6">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the degree of any (and all) <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>'s in the semigroup. </p>

</div>
</div>
<a id="a7cf2803e182aed6fbbb9a0b392d92316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf2803e182aed6fbbb9a0b392d92316">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a95514b17592385e49be35b4a08a5c7b4">const_iterator</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to one past the last currently known element of the semigroup. </p>
<p>This method does not perform any enumeration of the semigroup, the iterator returned may be invalidated by any call to a non-const method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class. </p>

</div>
</div>
<a id="adc5e3d6358f5011c8fcefd59c42fca2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5e3d6358f5011c8fcefd59c42fca2f">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::enumerate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> = <code>LIMIT_MAX</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the semigroup until <code>limit</code> elements are found or <code>killed</code> is <code>true</code>. </p>
<p>This is the main method of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class, where the Froidure-Pin Algorithm is implemented.</p>
<p>If the semigroup is already fully enumerated, or the number of elements previously enumerated exceeds <code>limit</code>, then calling this method does nothing. Otherwise, enumerate attempts to find at least the maximum of <code>limit</code> and <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#afdea8a2639f0ef0f27f1a56a1b1dc31b" title="Returns the current value of the batch size. This is the minimum number of elements enumerated in any...">FroidurePin::batch_size</a> elements of the semigroup. If <code>killed</code> is set to <code>true</code> (usually by another process), then the enumeration is terminated as soon as possible. It is possible to resume enumeration at some later point after any call to this method, even if it has been killed.</p>
<p>If the semigroup is fully enumerated, then it knows its left and right Cayley graphs, and a minimal factorisation of every element (in terms of its generating set). All of the elements are stored in memory until the object is destroyed.</p>
<p>The parameter <code>limit</code> defaults to FroidurePin::LIMIT_MAX. </p>

</div>
</div>
<a id="afa83e5e0ab5bad64db7efabe6b6f3689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa83e5e0ab5bad64db7efabe6b6f3689">&#9670;&nbsp;</a></span>equal_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::equal_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the parameters represent the same element of the semigroup and <code>false</code> otherwise. </p>

</div>
</div>
<a id="ae48be964090f90f5523d4d4a52b7333e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48be964090f90f5523d4d4a52b7333e">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; <a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a>, internal::hash&lt; <a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a> &gt;, internal::equal_to&lt; <a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a> &gt;, TraitsHashEqual&lt; <a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a>, internal::hash&lt; <a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a> &gt;, internal::equal_to&lt; <a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a> &gt; &gt; &gt;::factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_k_b_e.html">KBE</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to <code>x</code>. </p>
<p>Specialises the factorisation method for <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a>'s of <a class="el" href="classlibsemigroups_1_1_k_b_e.html" title="Subclass of Element that wraps an libsemigroups::internal_string_type. ">KBE</a>'s so that it just returns the word inside the <a class="el" href="classlibsemigroups_1_1_k_b_e.html" title="Subclass of Element that wraps an libsemigroups::internal_string_type. ">KBE</a>. </p>

</div>
</div>
<a id="a474b1533a0b0a28a9bc4e4e6e4bd7d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474b1533a0b0a28a9bc4e4e6e4bd7d6a">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes <code>word</code> in-place to contain a word in the generators equal to the <code>pos</code> element of the semigroup. </p>
<p>The key difference between this method and <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ab9833f76f7b7e83d381c2a43e2d30d99" title="Changes word in-place to contain a minimal word with respect to the short-lex ordering in the generat...">FroidurePin::minimal_factorisation</a>(word_type&amp; word, element_index_type pos), is that the resulting factorisation may not be minimal. If <code>pos</code> is greater than the size of the semigroup, then a LIBSEMIGROUPS_EXCEPTION is thrown. </p>

</div>
</div>
<a id="ad0b43f8e52fb8b0a0c82f3e8ff07a4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b43f8e52fb8b0a0c82f3e8ff07a4dc">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::factorisation </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>. </p>
<p>The key difference between this method and <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#afc1b09e5070e36b0bf6e7b74f9195856" title="Returns a minimal libsemigroups::word_type which evaluates to the Element in position pos of this...">FroidurePin::minimal_factorisation(element_index_type pos)</a>, is that the resulting factorisation may not be minimal. If <code>pos</code> is greater than the size of the semigroup, then a LIBSEMIGROUPS_EXCEPTION is thrown. </p>

</div>
</div>
<a id="a9a496d549156a988778b7a239ca31bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a496d549156a988778b7a239ca31bf4">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::factorisation </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to <code>x</code>. </p>
<p>The key difference between this method and <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a72ed8124ca1ec569613cb9a4ebb86b43" title="Returns a minimal libsemigroups::word_type which evaluates to x. ">FroidurePin::minimal_factorisation(const_reference x)</a>, is that the resulting factorisation may not be minimal. If <code>pos</code> is greater than the size of the semigroup, then a LIBSEMIGROUPS_EXCEPTION is thrown. </p>

</div>
</div>
<a id="a38edd613f421b9811558c9e1ee1aebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38edd613f421b9811558c9e1ee1aebc7">&#9670;&nbsp;</a></span>fast_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::fast_product </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code>. </p>
<p>The values <code>i</code> and <code>j</code> must be less than <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a36043572ffb87cb4c9b37b54e1a48ff1" title="Returns the number of elements in the semigroup that have been enumerated so far. ...">FroidurePin::current_size</a>, or a LIBSEMIGROUPS_EXCEPTION will be thrown. This method either:</p>
<ul>
<li>follows the path in the right or left Cayley graph from <code>i</code> to <code>j</code>, whichever is shorter using <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af56819977d388c7204f100850efa8a9f" title="Returns the position in this of the product of this-&gt;at(i) and this-&gt;at(j) by following a path in the...">FroidurePin::product_by_reduction</a>; or</li>
<li>multiplies the elements in postions <code>i</code> and <code>j</code> together;</li>
</ul>
<p>whichever is better. The method used is determined by comparing <a class="el" href="classlibsemigroups_1_1_element.html#ac7d80fabf8c999e505980ec0cf64a55a" title="Returns the approximate time complexity of multiplying two Element objects in a given subclass...">Element::complexity</a> and the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac531f191e24219771f913b336916c95b" title="Returns the length of the element in position pos of the semigroup. ">FroidurePin::length_const</a> of <code>i</code> and <code>j</code>.</p>
<p>For example, if the <a class="el" href="classlibsemigroups_1_1_element.html#ac7d80fabf8c999e505980ec0cf64a55a" title="Returns the approximate time complexity of multiplying two Element objects in a given subclass...">Element::complexity</a> of the multiplication is linear and <code>this</code> is a semigroup of transformations of degree 20, and the shortest paths in the left and right Cayley graphs from <code>i</code> to <code>j</code> are of length 100 and 1131, then it better to just product the transformations together. </p>

</div>
</div>
<a id="ad2ee9cbfcca17b7ea551afdc33589267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ee9cbfcca17b7ea551afdc33589267">&#9670;&nbsp;</a></span>final_letter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::final_letter </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last letter of the element in position <code>pos</code>. </p>
<p>This method returns the final letter of the element in position <code>pos</code> of the semigroup, which is the index of the generator corresponding to the final letter of the element.</p>
<p>Note that FroidurePin::gens[<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad2ee9cbfcca17b7ea551afdc33589267" title="Returns the last letter of the element in position pos. ">FroidurePin::final_letter</a>(<code>pos</code>)] is only equal to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7272ba920f61eb20fdaad08e25e0ca8a" title="Returns the element of the semigroup in position pos, or a nullptr if there is no such element...">FroidurePin::at</a>(<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ad2ee9cbfcca17b7ea551afdc33589267" title="Returns the last letter of the element in position pos. ">FroidurePin::final_letter</a>(<code>pos</code>)) if there are no duplicate generators.</p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="addbbdbe9438eee4aa6e953fcde6a7b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbbdbe9438eee4aa6e953fcde6a7b8d">&#9670;&nbsp;</a></span>first_letter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::first_letter </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first letter of the element in position <code>pos</code>. </p>
<p>This method returns the first letter of the element in position <code>pos</code> of the semigroup, which is the index of the generator corresponding to the first letter of the element.</p>
<p>Note that FroidurePin::gens[<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#addbbdbe9438eee4aa6e953fcde6a7b8d" title="Returns the first letter of the element in position pos. ">FroidurePin::first_letter</a>(<code>pos</code>)] is only equal to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a7272ba920f61eb20fdaad08e25e0ca8a" title="Returns the element of the semigroup in position pos, or a nullptr if there is no such element...">FroidurePin::at</a>(<a class="el" href="classlibsemigroups_1_1_froidure_pin.html#addbbdbe9438eee4aa6e953fcde6a7b8d" title="Returns the first letter of the element in position pos. ">FroidurePin::first_letter</a>(<code>pos</code>)) if there are no duplicate generators.</p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="a97210d28b09d11ffce68c29044063d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97210d28b09d11ffce68c29044063d5c">&#9670;&nbsp;</a></span>generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the generator with index <code>pos</code>. </p>
<p>If <code>pos</code> is not less than <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8957d580797dcbac29ccf209c4424c68" title="Returns the number of generators of the semigroup. ">FroidurePin::nr_generators()</a>, a LIBSEMIGROUPS_EXCEPTION will be thrown. Note that FroidurePin::gens(pos) is in general in general not in position <code>pos</code> in the semigroup, i.e. is not equal to FroidurePin::at(pos). </p>

</div>
</div>
<a id="aebc730ee9c1c395f798fcdb2ef8820a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc730ee9c1c395f798fcdb2ef8820a1">&#9670;&nbsp;</a></span>is_idempotent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::is_idempotent </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the element in position <code>pos</code> is an idempotent and <code>false</code> if it is not. </p>
<p>The parameter <code>pos</code> must be a valid position of an element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. This method involves fully enumerating the semigroup, if it is not already fully enumerated. </p>

</div>
</div>
<a id="ae357292be3b90ba4169ec9893b207c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357292be3b90ba4169ec9893b207c81">&#9670;&nbsp;</a></span>left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::left </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the product of the generator with index <code>j</code> and the element in position <code>i</code>. </p>
<p>This method fully enumerates the semigroup. </p>

</div>
</div>
<a id="ac531f191e24219771f913b336916c95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac531f191e24219771f913b336916c95b">&#9670;&nbsp;</a></span>length_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::length_const </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the element in position <code>pos</code> of the semigroup. </p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. This method causes no enumeration of the semigroup. </p>

</div>
</div>
<a id="aae7e05b9facc3fb71037ead65ae245b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7e05b9facc3fb71037ead65ae245b6">&#9670;&nbsp;</a></span>length_non_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::length_non_const </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the element in position <code>pos</code> of the semigroup. </p>
<p>The parameter <code>pos</code> must be a valid position of an element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="a17b152c493a7a8a37a4301a2ed74aeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b152c493a7a8a37a4301a2ed74aeee">&#9670;&nbsp;</a></span>letter_to_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::letter_to_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in <code>this</code> of the generator with index <code>i</code>. </p>
<p>If <code>i</code> is not a valid generator index, a LIBSEMIGROUPS_EXCEPTION will be thrown. In many cases <code>letter_to_pos(i)</code> will equal <code>i</code>, examples of when this will not be the case are:</p>
<ul>
<li>there are duplicate generators;</li>
<li>FroidurePin::add_generators was called after the semigroup was already partially enumerated. </li>
</ul>

</div>
</div>
<a id="a60b8c86827687805d830684c4cfdf96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b8c86827687805d830684c4cfdf96d">&#9670;&nbsp;</a></span>max_threads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::max_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value of. </p>

</div>
</div>
<a id="ab9833f76f7b7e83d381c2a43e2d30d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9833f76f7b7e83d381c2a43e2d30d99">&#9670;&nbsp;</a></span>minimal_factorisation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::minimal_factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes <code>word</code> in-place to contain a minimal word with respect to the short-lex ordering in the generators equal to the <code>pos</code> element of the semigroup. </p>
<p>If <code>pos</code> is less than the size of this semigroup, then this method changes its first parameter <code>word</code> in-place by first clearing it and then to contain a minimal factorization of the element in position <code>pos</code> of the semigroup with respect to the generators of the semigroup. This method enumerates the semigroup until at least the <code>pos</code> element is known. If <code>pos</code> is greater than the size of the semigroup, then a LIBSEMIGROUPS_EXCEPTION is thrown. </p>

</div>
</div>
<a id="afc1b09e5070e36b0bf6e7b74f9195856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1b09e5070e36b0bf6e7b74f9195856">&#9670;&nbsp;</a></span>minimal_factorisation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::minimal_factorisation </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a minimal <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>. </p>
<p>This is the same as the two-argument method for <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ab9833f76f7b7e83d381c2a43e2d30d99" title="Changes word in-place to contain a minimal word with respect to the short-lex ordering in the generat...">FroidurePin::minimal_factorisation</a>, but it returns a pointer to the factorisation instead of modifying an argument in-place. If <code>pos</code> is greater than the size of the semigroup, then a LIBSEMIGROUPS_EXCEPTION is thrown. </p>

</div>
</div>
<a id="a72ed8124ca1ec569613cb9a4ebb86b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ed8124ca1ec569613cb9a4ebb86b43">&#9670;&nbsp;</a></span>minimal_factorisation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::minimal_factorisation </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a minimal <a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_type</a> which evaluates to <code>x</code>. </p>
<p>This is the same as the method taking a FroidurePin::element_index_type, but it factorises an <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> instead of using the position of an element. If <code>pos</code> is greater than the size of the semigroup, then a LIBSEMIGROUPS_EXCEPTION is thrown. </p>

</div>
</div>
<a id="ac8d1b8bbb713d52bd72e1d085b6d1370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d1b8bbb713d52bd72e1d085b6d1370">&#9670;&nbsp;</a></span>next_relation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::next_relation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> &amp;&#160;</td>
          <td class="paramname"><em>relation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method changes <code>relation</code> in-place to contain the next relation of the presentation defining <code>this</code>. </p>
<p>This method changes <code>relation</code> in-place so that one of the following holds:</p>
<ul>
<li><code>relation</code> is a vector consisting of a <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7" title="Type for the index of a generator of a semigroup. ">libsemigroups::letter_type</a> and a <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7" title="Type for the index of a generator of a semigroup. ">libsemigroups::letter_type</a> such that FroidurePin::gens(<code>relation</code>[<code>0</code>]) == FroidurePin::gens(<code>relation</code>[<code>1</code>]), i.e. if the semigroup was defined with duplicate generators;</li>
<li><code>relation</code> is a vector consisting of a libsemigroups::element_index_type, <a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7" title="Type for the index of a generator of a semigroup. ">libsemigroups::letter_type</a>, and libsemigroups::element_index_type such that <div class="fragment"><div class="line"><span class="keyword">this</span>[relation[0]] * FroidurePin::gens(relation[1]) ==</div><div class="line"><span class="keyword">this</span>[relation[2]]</div></div><!-- fragment --></li>
<li><code>relation</code> is empty if there are no more relations.</li>
</ul>
<p><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac8d1b8bbb713d52bd72e1d085b6d1370" title="This method changes relation in-place to contain the next relation of the presentation defining this...">FroidurePin::next_relation</a> is guaranteed to output all relations of length 2 before any relations of length 3. If called repeatedly after <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a41f9d80e0a0cfd602ad835d1cf20ebca" title="This method resets FroidurePin::next_relation so that when it is next called the resulting relation i...">FroidurePin::reset_next_relation</a>, and until relation is empty, the values placed in <code>relation</code> correspond to a length-reducing confluent rewriting system that defines the semigroup.</p>
<p>This method can be used in conjunction with <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a474b1533a0b0a28a9bc4e4e6e4bd7d6a" title="Changes word in-place to contain a word in the generators equal to the pos element of the semigroup...">FroidurePin::factorisation</a> to obtain a presentation defining the semigroup.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a41f9d80e0a0cfd602ad835d1cf20ebca" title="This method resets FroidurePin::next_relation so that when it is next called the resulting relation i...">FroidurePin::reset_next_relation</a>. </dd></dl>

</div>
</div>
<a id="a8957d580797dcbac29ccf209c4424c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8957d580797dcbac29ccf209c4424c68">&#9670;&nbsp;</a></span>nr_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::nr_generators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generators of the semigroup. </p>

</div>
</div>
<a id="a764b475c8b4739d2457e287cf3b26fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764b475c8b4739d2457e287cf3b26fbe">&#9670;&nbsp;</a></span>nr_idempotents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::nr_idempotents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of idempotents in the semigroup. </p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. The value of the positions, and number, of idempotents is stored after they are first computed. </p>

</div>
</div>
<a id="af5e4a47614e66e635263013841457454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e4a47614e66e635263013841457454">&#9670;&nbsp;</a></span>nr_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::nr_rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of relations in the presentation defining the semigroup. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac8d1b8bbb713d52bd72e1d085b6d1370" title="This method changes relation in-place to contain the next relation of the presentation defining this...">FroidurePin::next_relation</a>. </dd></dl>

</div>
</div>
<a id="a4dc0a7d8cec826a413e366d84a70b710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc0a7d8cec826a413e366d84a70b710">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a>&amp; <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_froidure_pin.html">FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>semigroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>
<p>The <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> class does not support an assignment contructor to avoid accidental copying. An object in <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> may use many gigabytes of memory and might be extremely expensive to copy. A copy constructor is provided in case such a copy should it be required anyway. </p>

</div>
</div>
<a id="aef72a816855599c4a65aaeb0d3ccc2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef72a816855599c4a65aaeb0d3ccc2bb">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element of the semigroup in position <code>pos</code>. </p>
<p>This method performs no checks on its argument, and performs no enumeration of the semigroup. </p>

</div>
</div>
<a id="a0e59c62785dc2ff194c5cc80c41d6cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e59c62785dc2ff194c5cc80c41d6cd6">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of <code>x</code> in <code>this</code>, or FroidurePin::UNDEFINED if <code>x</code> is not an element of <code>this</code>. </p>
<p>This method can be used to find the FroidurePin::element_index_type position of the element <code>x</code> if it belongs to the semigroup. The semigroup is enumerated in batches until <code>x</code> is found or the semigroup is fully enumerated but <code>x</code> was not found (see <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a81169e9e015985bf7959c9aa5bef4a27" title="Set a new value for the batch size. ">FroidurePin::set_batch_size</a>). </p>

</div>
</div>
<a id="a26ac9a1b71e0a93e210e6a4bfbaaa508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ac9a1b71e0a93e210e6a4bfbaaa508">&#9670;&nbsp;</a></span>position_to_sorted_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::position_to_sorted_position </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of <code>this-&gt;at(pos)</code> in the sorted array of elements of the semigroup, or FroidurePin::UNDEFINED if <code>pos</code> is greater than the size of the semigroup. </p>

</div>
</div>
<a id="a4e19cb1cd60cb19c952155c3a69c486b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e19cb1cd60cb19c952155c3a69c486b">&#9670;&nbsp;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::prefix </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the prefix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>. </p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="af56819977d388c7204f100850efa8a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56819977d388c7204f100850efa8a9f">&#9670;&nbsp;</a></span>product_by_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::product_by_reduction </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code> by following a path in the Cayley graph. </p>
<p>The values <code>i</code> and <code>j</code> must be less than <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a36043572ffb87cb4c9b37b54e1a48ff1" title="Returns the number of elements in the semigroup that have been enumerated so far. ...">FroidurePin::current_size</a>, or a LIBSEMIGROUPS_EXCEPTION will be thrown. This method returns the position FroidurePin::element_index_type in the semigroup of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code> elements by following the path in the right Cayley graph from <code>i</code> labelled by the word <code>this-&gt;minimal_factorisation(j)</code> or, if this-&gt;minimal_factorisation(i) is shorter, by following the path in the left Cayley graph from <code>j</code> labelled by this-&gt;minimal_factorisation(i). </p>

</div>
</div>
<a id="a3075dd5bd843e43f1b5ce2ccda40a77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3075dd5bd843e43f1b5ce2ccda40a77a">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the capacity (i.e. number of elements) of the semigroup be at least enough to contain n elements. </p>
<p>The parameter <code>n</code> is also used to initialise certain data members, if you know a good upper bound for the size of your semigroup, then it is a good idea to call this method with that upper bound as an argument, this can significantly improve the performance of the <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5e3d6358f5011c8fcefd59c42fca2f" title="Enumerate the semigroup until limit elements are found or killed is true. ">FroidurePin::enumerate</a> method, and consequently every other method too. </p>

</div>
</div>
<a id="a41f9d80e0a0cfd602ad835d1cf20ebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f9d80e0a0cfd602ad835d1cf20ebca">&#9670;&nbsp;</a></span>reset_next_relation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::reset_next_relation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method resets <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac8d1b8bbb713d52bd72e1d085b6d1370" title="This method changes relation in-place to contain the next relation of the presentation defining this...">FroidurePin::next_relation</a> so that when it is next called the resulting relation is the first one. </p>
<p>After a call to this function, the next call to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#ac8d1b8bbb713d52bd72e1d085b6d1370" title="This method changes relation in-place to contain the next relation of the presentation defining this...">FroidurePin::next_relation</a> will return the first relation of the presentation defining the semigroup. </p>

</div>
</div>
<a id="a317c01d4a2a0db764d2e505b14057917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317c01d4a2a0db764d2e505b14057917">&#9670;&nbsp;</a></span>right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::right </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#ae76d5a532336fcdead943379d7b9cec7">letter_type</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the product of the element in position <code>i</code> with the generator with index <code>j</code>. </p>
<p>This method fully enumerates the semigroup. </p>

</div>
</div>
<a id="a81169e9e015985bf7959c9aa5bef4a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81169e9e015985bf7959c9aa5bef4a27">&#9670;&nbsp;</a></span>set_batch_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::set_batch_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new value for the batch size. </p>
<p>The <em>batch size</em> is the number of new elements to be found by any call to <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#adc5e3d6358f5011c8fcefd59c42fca2f" title="Enumerate the semigroup until limit elements are found or killed is true. ">FroidurePin::enumerate</a>. A call to enumerate returns between 0 and approximately the batch size.</p>
<p>The default value of the batch size is 8192.</p>
<p>This is used by, for example, <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a0e59c62785dc2ff194c5cc80c41d6cd6" title="Returns the position of x in this, or FroidurePin::UNDEFINED if x is not an element of this...">FroidurePin::position</a> so that it is possible to find the position of an element without fully enumerating the semigroup. </p>

</div>
</div>
<a id="aac64640965625a67d2301b27b9401039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac64640965625a67d2301b27b9401039">&#9670;&nbsp;</a></span>set_concurrency_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::set_concurrency_threshold </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value of. </p>

</div>
</div>
<a id="a7ec2111e45f6eb680ea16d1f422b294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec2111e45f6eb680ea16d1f422b294c">&#9670;&nbsp;</a></span>set_max_threads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::set_max_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of threads that any method of an instance of <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> can use. </p>
<p>This method sets the maximum number of threads to be used by any method of a <a class="el" href="classlibsemigroups_1_1_froidure_pin.html" title="Class for semigroups generated by instances of Element. ">FroidurePin</a> object. The number of threads is limited to the maximum of 1 and the minimum of <code>nr_threads</code> and the number of threads supported by the hardware. </p>

</div>
</div>
<a id="a1d2b2470b22ebc3086cb2776d2aa8f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2b2470b22ebc3086cb2776d2aa8f1c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the semigroup. </p>

</div>
</div>
<a id="a5704eea9805fc949f14ea8c2b9993a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5704eea9805fc949f14ea8c2b9993a79">&#9670;&nbsp;</a></span>sorted_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::sorted_at </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element of the semigroup in position <code>pos</code> of the sorted array of elements, or <code>nullptr</code> in <code>pos</code> is not valid (i.e. too big). </p>
<p>This method fully enumerates the semigroup. </p>

</div>
</div>
<a id="ae824ef2c3eb24c7fe799ebc9824a020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae824ef2c3eb24c7fe799ebc9824a020a">&#9670;&nbsp;</a></span>sorted_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::sorted_position </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of <code>x</code> in the sorted array of elements of the semigroup, or FroidurePin::UNDEFINED if <code>x</code> is not an element of <code>this</code>. </p>

</div>
</div>
<a id="a97dbe95a65c0a9f93a20813ff987fdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dbe95a65c0a9f93a20813ff987fdae">&#9670;&nbsp;</a></span>suffix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::suffix </td>
          <td>(</td>
          <td class="paramtype">element_index_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the suffix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>. </p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown. </p>

</div>
</div>
<a id="af7c4d105196420d362c76de79ec0bdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4d105196420d362c76de79ec0bdf9">&#9670;&nbsp;</a></span>word_to_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">element_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::word_to_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the element of <code>this</code> represented by the word <code>w</code>. </p>
<p>The parameter <code>w</code> must consist of non-negative integers less than FroidurePin::nrgens, or a LIBSEMIGROUPS_EXCEPTION will be thrown. This method returns a copy of the element of <code>this</code> obtained by evaluating <code>w</code>. This is equivalent to finding the product <code>x</code> of the generators FroidurePin::gens(<code>w</code>[i]).</p>
<p>A copy is returned instead of a reference, because the element of <code>this</code> corresponding to <code>w</code> may not yet have been enumerated.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a015df010853f76a36374d3859d481cbe" title="Returns the position in the semigroup corresponding to the element represented by the word w...">FroidurePin::word_to_pos</a>. </dd></dl>

</div>
</div>
<a id="a015df010853f76a36374d3859d481cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015df010853f76a36374d3859d481cbe">&#9670;&nbsp;</a></span>word_to_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElementType  = Element const*, typename TElementHash  = internal::hash&lt;TElementType&gt;, typename TElementEqual  = internal::equal_to&lt;TElementType&gt;, class TTraits  = TraitsHashEqual&lt;TElementType, TElementHash, TElementEqual&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_index_type <a class="el" href="classlibsemigroups_1_1_froidure_pin.html">libsemigroups::FroidurePin</a>&lt; TElementType, TElementHash, TElementEqual, TTraits &gt;::word_to_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a676fa302ec473b5bef941c85cbdb3842">word_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in the semigroup corresponding to the element represented by the word <code>w</code>. </p>
<p>The parameter <code>w</code> must consist of non-negative integers less than <a class="el" href="classlibsemigroups_1_1_froidure_pin.html#a8957d580797dcbac29ccf209c4424c68" title="Returns the number of generators of the semigroup. ">FroidurePin::nr_generators</a>, or a LibsemigroupsException will be thrown. This method returns the position in <code>this</code> of the element obtained by evaluating <code>w</code>. This method does not perform any enumeration of the semigroup, and will return <a class="el" href="structlibsemigroups_1_1_u_n_d_e_f_i_n_e_d.html" title="UNDEFINED value. ">UNDEFINED</a> if the position of the element of <code>this</code> corresponding to <code>w</code> cannot be determined.</p>
<p>This is equivalent to finding the product <code>x</code> of the generators FroidurePin::gens(<code>w</code>[i]) and then calling FroidurePin::position_current with argument <code>x</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_froidure_pin.html#af7c4d105196420d362c76de79ec0bdf9" title="Returns a copy of the element of this represented by the word w. ">FroidurePin::word_to_element</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="froidure-pin_8hpp_source.html">froidure-pin.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 8 2019 15:17:28 for libsemigroups by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
