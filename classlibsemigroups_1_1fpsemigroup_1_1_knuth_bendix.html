<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsemigroups: libsemigroups::fpsemigroup::KnuthBendix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><b>fpsemigroup</b></li><li class="navelem"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html">KnuthBendix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libsemigroups::fpsemigroup::KnuthBendix Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is used to represent a <a href="https://en.wikipedia.org/wiki/Semi-Thue_system">string rewriting system</a> defining a finitely presented monoid or semigroup.  
 <a href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="knuth-bendix_8hpp_source.html">knuth-bendix.hpp</a>&gt;</code></p>

<p>Inherits libsemigroups::FpSemiBase.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abf82affa7388eafb150426a8565e2ccc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#abf82affa7388eafb150426a8565e2ccc">overlap_policy</a> { <b>ABC</b> = 0, 
<b>AB_BC</b> = 1, 
<b>MAX_AB_BC</b> = 2
 }</td></tr>
<tr class="memdesc:abf82affa7388eafb150426a8565e2ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values in this enum determine how a rewriting system measures the length \(d(AB, BC)\) of the overlap of two words \(AB\) and \(BC\):  <a href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#abf82affa7388eafb150426a8565e2ccc">More...</a><br /></td></tr>
<tr class="separator:abf82affa7388eafb150426a8565e2ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa70ef97b0e8a9fdc150c3256c8cc3364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#aa70ef97b0e8a9fdc150c3256c8cc3364">KnuthBendix</a> (<a class="el" href="classlibsemigroups_1_1_reduction_ordering.html">ReductionOrdering</a> *)</td></tr>
<tr class="memdesc:aa70ef97b0e8a9fdc150c3256c8cc3364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs rewriting system with no rules and the reduction ordering <code>order</code>.  <a href="#aa70ef97b0e8a9fdc150c3256c8cc3364">More...</a><br /></td></tr>
<tr class="separator:aa70ef97b0e8a9fdc150c3256c8cc3364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef6f9e318ca7b19cbb765b4c1b4f54"><td class="memItemLeft" align="right" valign="top"><a id="a5bef6f9e318ca7b19cbb765b4c1b4f54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KnuthBendix</b> (FroidurePinBase &amp;)</td></tr>
<tr class="separator:a5bef6f9e318ca7b19cbb765b4c1b4f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebea954101c6fcf88bb2292c85a4779a"><td class="memItemLeft" align="right" valign="top"><a id="aebea954101c6fcf88bb2292c85a4779a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KnuthBendix</b> (<a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html">KnuthBendix</a> const *)</td></tr>
<tr class="separator:aebea954101c6fcf88bb2292c85a4779a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd603c3dde7bec92cf1f758a0919edc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a8bd603c3dde7bec92cf1f758a0919edc">KnuthBendix</a> ()</td></tr>
<tr class="memdesc:a8bd603c3dde7bec92cf1f758a0919edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rewriting system with no rules, and the <a class="el" href="classlibsemigroups_1_1_s_h_o_r_t_l_e_x.html" title="This class implements the shortlex reduction ordering derived from an ordering on libsemigroups::rws_...">SHORTLEX</a> reduction ordering.  <a href="#a8bd603c3dde7bec92cf1f758a0919edc">More...</a><br /></td></tr>
<tr class="separator:a8bd603c3dde7bec92cf1f758a0919edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d3ec0acc6303c8f715688281df9f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a5f1d3ec0acc6303c8f715688281df9f5">~KnuthBendix</a> ()</td></tr>
<tr class="memdesc:a5f1d3ec0acc6303c8f715688281df9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default destructor.  <a href="#a5f1d3ec0acc6303c8f715688281df9f5">More...</a><br /></td></tr>
<tr class="separator:a5f1d3ec0acc6303c8f715688281df9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c6ac253e8a4c7071b70de32d241fc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a35c6ac253e8a4c7071b70de32d241fc3">confluent</a> () const</td></tr>
<tr class="memdesc:a35c6ac253e8a4c7071b70de32d241fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the rewriting system is <a href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)">confluent</a> and <code>false</code> if it is not.  <a href="#a35c6ac253e8a4c7071b70de32d241fc3">More...</a><br /></td></tr>
<tr class="separator:a35c6ac253e8a4c7071b70de32d241fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67353db5bc46b43a9c1129055c0ffae"><td class="memItemLeft" align="right" valign="top"><a id="ab67353db5bc46b43a9c1129055c0ffae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal_to</b> (std::string const &amp;, std::string const &amp;) override</td></tr>
<tr class="separator:ab67353db5bc46b43a9c1129055c0ffae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d65a5de34c041e2b0ec75ba7ded15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15">knuth_bendix</a> ()</td></tr>
<tr class="memdesc:a0d6d65a5de34c041e2b0ec75ba7ded15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the <a href="https://en.wikipedia.org/wiki/Knuthâ€“Bendix_completion_algorithm">Knuth-Bendix algorithm</a> on the rewriting system.  <a href="#a0d6d65a5de34c041e2b0ec75ba7ded15">More...</a><br /></td></tr>
<tr class="separator:a0d6d65a5de34c041e2b0ec75ba7ded15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae332d33d4e6b6c65f242fb66f24fb7c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#ae332d33d4e6b6c65f242fb66f24fb7c9">knuth_bendix_by_overlap_length</a> ()</td></tr>
<tr class="memdesc:ae332d33d4e6b6c65f242fb66f24fb7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method runs the Knuth-Bendix algorithm on the rewriting system by considering all overlaps of a given length \(n\) (according to the KnuthBendix::overlap_measure) before those overlaps of length \(n + 1\).  <a href="#ae332d33d4e6b6c65f242fb66f24fb7c9">More...</a><br /></td></tr>
<tr class="separator:ae332d33d4e6b6c65f242fb66f24fb7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d18b0cf5ae0b7a1ab33952a4d7ccb7d"><td class="memItemLeft" align="right" valign="top"><a id="a0d18b0cf5ae0b7a1ab33952a4d7ccb7d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>normal_form</b> (std::string const &amp;) override</td></tr>
<tr class="separator:a0d18b0cf5ae0b7a1ab33952a4d7ccb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab684dc96480d7c252acb30ed6175f7dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#ab684dc96480d7c252acb30ed6175f7dc">nr_active_rules</a> () const noexcept</td></tr>
<tr class="memdesc:ab684dc96480d7c252acb30ed6175f7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of active rules in the rewriting system.  <a href="#ab684dc96480d7c252acb30ed6175f7dc">More...</a><br /></td></tr>
<tr class="separator:ab684dc96480d7c252acb30ed6175f7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325c4773f17ab5f9b0731688438dc58"><td class="memItemLeft" align="right" valign="top">std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#ad325c4773f17ab5f9b0731688438dc58">rewrite</a> (std::string *) const</td></tr>
<tr class="memdesc:ad325c4773f17ab5f9b0731688438dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the word <code>w</code> in-place according to the current rules in the rewriting system, and returns it.  <a href="#ad325c4773f17ab5f9b0731688438dc58">More...</a><br /></td></tr>
<tr class="separator:ad325c4773f17ab5f9b0731688438dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bfa8b4a12d69fbe7ba3ab50f9a3474"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a73bfa8b4a12d69fbe7ba3ab50f9a3474">rewrite</a> (std::string) const</td></tr>
<tr class="memdesc:a73bfa8b4a12d69fbe7ba3ab50f9a3474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a copy of the word <code>w</code> rewritten according to the current rules in the rewriting system.  <a href="#a73bfa8b4a12d69fbe7ba3ab50f9a3474">More...</a><br /></td></tr>
<tr class="separator:a73bfa8b4a12d69fbe7ba3ab50f9a3474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573e68658a6ec48c8d2fe12d6b30b3f5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a573e68658a6ec48c8d2fe12d6b30b3f5">rules</a> () const</td></tr>
<tr class="memdesc:a573e68658a6ec48c8d2fe12d6b30b3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a vector consisting of the pairs of strings which represent the rules of the rewriting system. The <code>first</code> entry in every such pair is greater than the <code>second</code> according to the reduction ordering of the rewriting system. The rules are sorted according to the reduction ordering used by the rewriting system, on the first entry.  <a href="#a573e68658a6ec48c8d2fe12d6b30b3f5">More...</a><br /></td></tr>
<tr class="separator:a573e68658a6ec48c8d2fe12d6b30b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae628b2d5669a8a3b5a7ac7050f4d9f8c"><td class="memItemLeft" align="right" valign="top"><a id="ae628b2d5669a8a3b5a7ac7050f4d9f8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> () override</td></tr>
<tr class="separator:ae628b2d5669a8a3b5a7ac7050f4d9f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40636f1675aedba5443b8a5136d58dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a40636f1675aedba5443b8a5136d58dbf">set_check_confluence_interval</a> (size_t)</td></tr>
<tr class="memdesc:a40636f1675aedba5443b8a5136d58dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> periodically checks if the system is already confluent. This method can be used to set how frequently this happens, it is the number of new overlaps that should be considered before checking confluence. Setting this value too low can adversely affect the performance of <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>.  <a href="#a40636f1675aedba5443b8a5136d58dbf">More...</a><br /></td></tr>
<tr class="separator:a40636f1675aedba5443b8a5136d58dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46710039265c6fe0a13ba0359afb9c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a46710039265c6fe0a13ba0359afb9c0b">set_max_overlap</a> (size_t)</td></tr>
<tr class="memdesc:a46710039265c6fe0a13ba0359afb9c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method can be used to specify the maximum length of the overlap of two left hand sides of rules that should be considered in <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>.  <a href="#a46710039265c6fe0a13ba0359afb9c0b">More...</a><br /></td></tr>
<tr class="separator:a46710039265c6fe0a13ba0359afb9c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485b6823b5da455b991b7a20b179698a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a485b6823b5da455b991b7a20b179698a">set_max_rules</a> (size_t)</td></tr>
<tr class="memdesc:a485b6823b5da455b991b7a20b179698a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the (approximate) maximum number of rules that the system should contain. If this is number is exceeded in calls to <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> or <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#ae332d33d4e6b6c65f242fb66f24fb7c9" title="This method runs the Knuth-Bendix algorithm on the rewriting system by considering all overlaps of a ...">KnuthBendix::knuth_bendix_by_overlap_length</a>, then these methods will terminate and the system may not be confluent.  <a href="#a485b6823b5da455b991b7a20b179698a">More...</a><br /></td></tr>
<tr class="separator:a485b6823b5da455b991b7a20b179698a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957f44313af79a19ec1d0bbabd7e1713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a957f44313af79a19ec1d0bbabd7e1713">set_overlap_policy</a> (<a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#abf82affa7388eafb150426a8565e2ccc">overlap_policy</a>)</td></tr>
<tr class="memdesc:a957f44313af79a19ec1d0bbabd7e1713"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method can be used to determine the way that the length of an overlap of two words in the system is meaasured.  <a href="#a957f44313af79a19ec1d0bbabd7e1713">More...</a><br /></td></tr>
<tr class="separator:a957f44313af79a19ec1d0bbabd7e1713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857deb15e69c9d704b5ca0774577423f"><td class="memItemLeft" align="right" valign="top"><a id="a857deb15e69c9d704b5ca0774577423f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () override</td></tr>
<tr class="separator:a857deb15e69c9d704b5ca0774577423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6cdf5d71069ebf90936a6722d49c652d"><td class="memItemLeft" align="right" valign="top"><a id="a6cdf5d71069ebf90936a6722d49c652d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>::libsemigroups::congruence::KnuthBendix</b></td></tr>
<tr class="separator:a6cdf5d71069ebf90936a6722d49c652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c92294d7d8063c34c50bf9125931441"><td class="memItemLeft" align="right" valign="top"><a id="a8c92294d7d8063c34c50bf9125931441"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>::libsemigroups::KBE</b></td></tr>
<tr class="separator:a8c92294d7d8063c34c50bf9125931441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384446d47117737fe99077e050709760"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a384446d47117737fe99077e050709760">operator&lt;&lt;</a> (std::ostream &amp;, <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html">KnuthBendix</a> const &amp;)</td></tr>
<tr class="memdesc:a384446d47117737fe99077e050709760"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows a <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html" title="This class is used to represent a string rewriting system defining a finitely presented monoid or sem...">KnuthBendix</a> object to be left shifted into a std::ostream, such as std::cout. The currently active rules of the system are represented in the output.  <a href="#a384446d47117737fe99077e050709760">More...</a><br /></td></tr>
<tr class="separator:a384446d47117737fe99077e050709760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is used to represent a <a href="https://en.wikipedia.org/wiki/Semi-Thue_system">string rewriting system</a> defining a finitely presented monoid or semigroup. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="abf82affa7388eafb150426a8565e2ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf82affa7388eafb150426a8565e2ccc">&#9670;&nbsp;</a></span>overlap_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#abf82affa7388eafb150426a8565e2ccc">libsemigroups::fpsemigroup::KnuthBendix::overlap_policy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The values in this enum determine how a rewriting system measures the length \(d(AB, BC)\) of the overlap of two words \(AB\) and \(BC\): </p>
<ul>
<li><em><b>ABC</b></em>: \(d(AB, BC) = |A| + |B| + |C|\)</li>
<li><em><b>AB_BC</b></em>: \(d(AB, BC) = |AB| + |BC|\)</li>
<li><em><b>MAX_AB_BC</b></em>: \(d(AB, BC) = max(|AB|, |BC|)\)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a957f44313af79a19ec1d0bbabd7e1713" title="This method can be used to determine the way that the length of an overlap of two words in the system...">KnuthBendix::set_overlap_policy</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa70ef97b0e8a9fdc150c3256c8cc3364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70ef97b0e8a9fdc150c3256c8cc3364">&#9670;&nbsp;</a></span>KnuthBendix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::fpsemigroup::KnuthBendix::KnuthBendix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_reduction_ordering.html">ReductionOrdering</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs rewriting system with no rules and the reduction ordering <code>order</code>. </p>
<p>This constructs a rewriting system with no rules, and with the reduction ordering <a class="el" href="classlibsemigroups_1_1_reduction_ordering.html" title="This class provides a call operator which can be used to compare libsemigroups::rws_word_t. ">ReductionOrdering</a> specifed by the parameter <code>order</code>. </p>

</div>
</div>
<a id="a8bd603c3dde7bec92cf1f758a0919edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd603c3dde7bec92cf1f758a0919edc">&#9670;&nbsp;</a></span>KnuthBendix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::fpsemigroup::KnuthBendix::KnuthBendix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rewriting system with no rules, and the <a class="el" href="classlibsemigroups_1_1_s_h_o_r_t_l_e_x.html" title="This class implements the shortlex reduction ordering derived from an ordering on libsemigroups::rws_...">SHORTLEX</a> reduction ordering. </p>

</div>
</div>
<a id="a5f1d3ec0acc6303c8f715688281df9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1d3ec0acc6303c8f715688281df9f5">&#9670;&nbsp;</a></span>~KnuthBendix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::fpsemigroup::KnuthBendix::~KnuthBendix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A default destructor. </p>
<p>This deletes the reduction order used to construct the object, and the rules in the system. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35c6ac253e8a4c7071b70de32d241fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c6ac253e8a4c7071b70de32d241fc3">&#9670;&nbsp;</a></span>confluent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libsemigroups::fpsemigroup::KnuthBendix::confluent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the rewriting system is <a href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)">confluent</a> and <code>false</code> if it is not. </p>

</div>
</div>
<a id="a0d6d65a5de34c041e2b0ec75ba7ded15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6d65a5de34c041e2b0ec75ba7ded15">&#9670;&nbsp;</a></span>knuth_bendix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::fpsemigroup::KnuthBendix::knuth_bendix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the <a href="https://en.wikipedia.org/wiki/Knuthâ€“Bendix_completion_algorithm">Knuth-Bendix algorithm</a> on the rewriting system. </p>
<dl class="section warning"><dt>Warning</dt><dd>This will terminate when the rewriting system is confluent, which might be never.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#ae332d33d4e6b6c65f242fb66f24fb7c9" title="This method runs the Knuth-Bendix algorithm on the rewriting system by considering all overlaps of a ...">knuth_bendix_by_overlap_length</a>. </dd></dl>

</div>
</div>
<a id="ae332d33d4e6b6c65f242fb66f24fb7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae332d33d4e6b6c65f242fb66f24fb7c9">&#9670;&nbsp;</a></span>knuth_bendix_by_overlap_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::fpsemigroup::KnuthBendix::knuth_bendix_by_overlap_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method runs the Knuth-Bendix algorithm on the rewriting system by considering all overlaps of a given length \(n\) (according to the KnuthBendix::overlap_measure) before those overlaps of length \(n + 1\). </p>
<dl class="section warning"><dt>Warning</dt><dd>This will terminate when the rewriting system is confluent, which might be never.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>. </dd></dl>

</div>
</div>
<a id="ab684dc96480d7c252acb30ed6175f7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab684dc96480d7c252acb30ed6175f7dc">&#9670;&nbsp;</a></span>nr_active_rules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::fpsemigroup::KnuthBendix::nr_active_rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of active rules in the rewriting system. </p>

</div>
</div>
<a id="ad325c4773f17ab5f9b0731688438dc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad325c4773f17ab5f9b0731688438dc58">&#9670;&nbsp;</a></span>rewrite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string* libsemigroups::fpsemigroup::KnuthBendix::rewrite </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the word <code>w</code> in-place according to the current rules in the rewriting system, and returns it. </p>

</div>
</div>
<a id="a73bfa8b4a12d69fbe7ba3ab50f9a3474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bfa8b4a12d69fbe7ba3ab50f9a3474">&#9670;&nbsp;</a></span>rewrite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libsemigroups::fpsemigroup::KnuthBendix::rewrite </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites a copy of the word <code>w</code> rewritten according to the current rules in the rewriting system. </p>

</div>
</div>
<a id="a573e68658a6ec48c8d2fe12d6b30b3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573e68658a6ec48c8d2fe12d6b30b3f5">&#9670;&nbsp;</a></span>rules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; libsemigroups::fpsemigroup::KnuthBendix::rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a vector consisting of the pairs of strings which represent the rules of the rewriting system. The <code>first</code> entry in every such pair is greater than the <code>second</code> according to the reduction ordering of the rewriting system. The rules are sorted according to the reduction ordering used by the rewriting system, on the first entry. </p>

</div>
</div>
<a id="a40636f1675aedba5443b8a5136d58dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40636f1675aedba5443b8a5136d58dbf">&#9670;&nbsp;</a></span>set_check_confluence_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::fpsemigroup::KnuthBendix::set_check_confluence_interval </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The method <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> periodically checks if the system is already confluent. This method can be used to set how frequently this happens, it is the number of new overlaps that should be considered before checking confluence. Setting this value too low can adversely affect the performance of <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>. </p>
<p>The default value is 4096, and should be set to KnuthBendix::UNBOUNDED if <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> should never check if the system is already confluent.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>. </dd></dl>

</div>
</div>
<a id="a46710039265c6fe0a13ba0359afb9c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46710039265c6fe0a13ba0359afb9c0b">&#9670;&nbsp;</a></span>set_max_overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::fpsemigroup::KnuthBendix::set_max_overlap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method can be used to specify the maximum length of the overlap of two left hand sides of rules that should be considered in <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>. </p>
<p>If this value is less than the longest left hand side of a rule, then <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> can terminate without the system being confluent.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>. </dd></dl>

</div>
</div>
<a id="a485b6823b5da455b991b7a20b179698a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485b6823b5da455b991b7a20b179698a">&#9670;&nbsp;</a></span>set_max_rules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::fpsemigroup::KnuthBendix::set_max_rules </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the (approximate) maximum number of rules that the system should contain. If this is number is exceeded in calls to <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> or <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#ae332d33d4e6b6c65f242fb66f24fb7c9" title="This method runs the Knuth-Bendix algorithm on the rewriting system by considering all overlaps of a ...">KnuthBendix::knuth_bendix_by_overlap_length</a>, then these methods will terminate and the system may not be confluent. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a> and <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#a0d6d65a5de34c041e2b0ec75ba7ded15" title="Run the Knuth-Bendix algorithm on the rewriting system. ">KnuthBendix::knuth_bendix</a>. </dd></dl>

</div>
</div>
<a id="a957f44313af79a19ec1d0bbabd7e1713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957f44313af79a19ec1d0bbabd7e1713">&#9670;&nbsp;</a></span>set_overlap_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::fpsemigroup::KnuthBendix::set_overlap_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html#abf82affa7388eafb150426a8565e2ccc">overlap_policy</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method can be used to determine the way that the length of an overlap of two words in the system is meaasured. </p>
<dl class="section see"><dt>See also</dt><dd>KnuthBendix::overlap_measure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a384446d47117737fe99077e050709760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384446d47117737fe99077e050709760">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html">KnuthBendix</a> const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows a <a class="el" href="classlibsemigroups_1_1fpsemigroup_1_1_knuth_bendix.html" title="This class is used to represent a string rewriting system defining a finitely presented monoid or sem...">KnuthBendix</a> object to be left shifted into a std::ostream, such as std::cout. The currently active rules of the system are represented in the output. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="knuth-bendix_8hpp_source.html">knuth-bendix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 20 2018 14:57:11 for libsemigroups by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
